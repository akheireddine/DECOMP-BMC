diff -rupN ./File.C ..\Minisat/File.C
--- ./File.C	2014-02-26 14:57:06.967510400 +0000
+++ ..\Minisat/File.C	1970-01-01 00:00:00.000000000 +0000
@@ -1,157 +0,0 @@
-#include "File.h"
-
-
-void File::open(int file_descr, FileMode m, bool own)
-{
-    if (fd != -1) ::close(fd);
-    fd     = file_descr;
-    mode   = m;
-    own_fd = own;
-    pos    = 0;
-    buf    = xmalloc<uchar>(File_BufSize);
-    if (mode == READ) size = read(fd, buf, File_BufSize);
-    else              size = -1;
-}
-
-void File::open(cchar* name, cchar* mode_)
-{
-    if (fd != -1) ::close(fd);
-    bool    has_r = strchr(mode_, 'r') != NULL;
-    bool    has_w = strchr(mode_, 'w') != NULL;
-    bool    has_a = strchr(mode_, 'a') != NULL;
-    bool    has_p = strchr(mode_, '+') != NULL;
-    bool    has_x = strchr(mode_, 'x') != NULL;
-    assert(!(has_r && has_w));
-    assert(has_r || has_w || has_a);
-
-    int mask = 0;
-    if      (has_p) mask |= O_RDWR;
-    else if (has_r) mask |= O_RDONLY;
-    else            mask |= O_WRONLY;
-
-    if (!has_r) mask |= O_CREAT;
-    if (has_w)  mask |= O_TRUNC;
-    if (has_x)  mask |= O_EXCL;
-
-    fd = open64(name, mask, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
-
-    if (fd != -1){
-        mode   = has_r ? READ : WRITE;
-        own_fd = true;
-        pos    = 0;
-        if (has_a) lseek64(fd, 0, SEEK_END);
-        buf    = xmalloc<uchar>(File_BufSize);
-        if (mode == READ) size = read(fd, buf, File_BufSize);
-        else              size = -1;
-    }
-}
-
-
-void File::close(void)
-{
-    if (fd == -1) return;
-    if (mode == WRITE)
-        flush();
-    xfree(buf); buf = NULL;
-    if (own_fd)
-        ::close(fd);
-    fd = -1;
-}
-
-void File::seek(int64 file_pos, int whence)
-{
-    if (mode == WRITE){
-        flush();
-        pos = 0;
-        lseek64(fd, file_pos, whence);
-    }else{
-        if (whence == SEEK_CUR) lseek64(fd, file_pos - (size - pos), SEEK_CUR);
-        else                    lseek64(fd, file_pos, whence);
-        size = read(fd, buf, File_BufSize);
-        pos = 0;
-    }
-}
-
-int64 File::tell(void)
-{
-    if (mode == WRITE)
-        return lseek64(fd, 0, SEEK_CUR);
-    else
-        return lseek64(fd, 0, SEEK_CUR) - (size - pos);
-}
-
-
-//=================================================================================================
-// Marshaling:
-
-
-void putUInt(File& out, uint64 val)
-{
-    if (val < 0x20000000){
-        uint    v = (uint)val;
-        if (v < 0x80)
-            out.putChar(v);
-        else{
-            if (v < 0x2000)
-                out.putChar(0x80 | (v >> 8)),
-                out.putChar((uchar)v);
-            else if (v < 0x200000)
-                out.putChar(0xA0 | (v >> 16)),
-                out.putChar((uchar)(v >> 8)),
-                out.putChar((uchar)v);
-            else
-                out.putChar((v >> 24) | 0xC0),
-                out.putChar((uchar)(v >> 16)),
-                out.putChar((uchar)(v >> 8)),
-                out.putChar((uchar)v);
-        }
-    }else
-        out.putChar(0xE0),
-        out.putChar((uchar)(val >> 56)),
-        out.putChar((uchar)(val >> 48)),
-        out.putChar((uchar)(val >> 40)),
-        out.putChar((uchar)(val >> 32)),
-        out.putChar((uchar)(val >> 24)),
-        out.putChar((uchar)(val >> 16)),
-        out.putChar((uchar)(val >> 8)),
-        out.putChar((uchar)val);
-}
-
-
-uint64 getUInt(File& in)
-    throw(Exception_EOF)
-{
-    uint byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7;
-    byte0 = in.getChar();
-    if (byte0 == (uint)EOF)
-        throw Exception_EOF();
-    if (!(byte0 & 0x80))
-        return byte0;
-    else{
-        switch ((byte0 & 0x60) >> 5){
-        case 0:
-            byte1 = in.getChar();
-            return ((byte0 & 0x1F) << 8) | byte1;
-        case 1:
-            byte1 = in.getChar();
-            byte2 = in.getChar();
-            return ((byte0 & 0x1F) << 16) | (byte1 << 8) | byte2;
-        case 2:
-            byte1 = in.getChar();
-            byte2 = in.getChar();
-            byte3 = in.getChar();
-            return ((byte0 & 0x1F) << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
-        default:
-            byte0 = in.getChar();
-            byte1 = in.getChar();
-            byte2 = in.getChar();
-            byte3 = in.getChar();
-            byte4 = in.getChar();
-            byte5 = in.getChar();
-            byte6 = in.getChar();
-            byte7 = in.getChar();
-            return ((uint64)((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3) << 32)
-                 |  (uint64)((byte4 << 24) | (byte5 << 16) | (byte6 << 8) | byte7);
-        }
-    }
-}
diff -rupN ./File.cpp ..\Minisat/File.cpp
--- ./File.cpp	1970-01-01 00:00:00.000000000 +0000
+++ ..\Minisat/File.cpp	2011-02-17 13:31:13.123202800 +0000
@@ -0,0 +1,157 @@
+#include "File.h"
+
+
+void File::open(int file_descr, FileMode m, bool own)
+{
+    if (fd != -1) ::_close(fd);
+    fd     = file_descr;
+    mode   = m;
+    own_fd = own;
+    pos    = 0;
+    buf    = xmalloc<uchar>(File_BufSize);
+    if (mode == READ) size = _read(fd, buf, File_BufSize);
+    else              size = -1;
+}
+
+void File::open(cchar* name, cchar* mode_)
+{
+    if (fd != -1) ::_close(fd);
+    bool    has_r = strchr(mode_, 'r') != NULL;
+    bool    has_w = strchr(mode_, 'w') != NULL;
+    bool    has_a = strchr(mode_, 'a') != NULL;
+    bool    has_p = strchr(mode_, '+') != NULL;
+    bool    has_x = strchr(mode_, 'x') != NULL;
+    assert(!(has_r && has_w));
+    assert(has_r || has_w || has_a);
+
+    int mask = 0;
+    if      (has_p) mask |= O_RDWR;
+    else if (has_r) mask |= O_RDONLY;
+    else            mask |= O_WRONLY;
+
+    if (!has_r) mask |= O_CREAT;
+    if (has_w)  mask |= O_TRUNC;
+    if (has_x)  mask |= O_EXCL;
+
+    fd = _open(name, mask);
+
+    if (fd != -1){
+        mode   = has_r ? READ : WRITE;
+        own_fd = true;
+        pos    = 0;
+        if (has_a) lseek64(fd, 0, SEEK_END);
+        buf    = xmalloc<uchar>(File_BufSize);
+        if (mode == READ) size = _read(fd, buf, File_BufSize);
+        else              size = -1;
+    }
+}
+
+
+void File::close(void)
+{
+    if (fd == -1) return;
+    if (mode == WRITE)
+        flush();
+    xfree(buf); buf = NULL;
+    if (own_fd)
+        ::_close(fd);
+    fd = -1;
+}
+
+void File::seek(int64 file_pos, int whence)
+{
+    if (mode == WRITE){
+        flush();
+        pos = 0;
+        lseek64(fd, (long)file_pos, whence);
+    }else{
+        if (whence == SEEK_CUR) lseek64(fd, (long) file_pos - (size - pos), SEEK_CUR);
+        else                    lseek64(fd, (long) file_pos, whence);
+        size = _read(fd, buf, File_BufSize);
+        pos = 0;
+    }
+}
+
+int64 File::tell(void)
+{
+    if (mode == WRITE)
+        return lseek64(fd, 0, SEEK_CUR);
+    else
+        return lseek64(fd, 0, SEEK_CUR) - (size - pos);
+}
+
+
+//=================================================================================================
+// Marshaling:
+
+
+void putUInt(File& out, uint64 val)
+{
+    if (val < 0x20000000){
+        uint    v = (uint)val;
+        if (v < 0x80)
+            out.putChar(v);
+        else{
+            if (v < 0x2000)
+                out.putChar(0x80 | (v >> 8)),
+                out.putChar((uchar)v);
+            else if (v < 0x200000)
+                out.putChar(0xA0 | (v >> 16)),
+                out.putChar((uchar)(v >> 8)),
+                out.putChar((uchar)v);
+            else
+                out.putChar((v >> 24) | 0xC0),
+                out.putChar((uchar)(v >> 16)),
+                out.putChar((uchar)(v >> 8)),
+                out.putChar((uchar)v);
+        }
+    }else
+        out.putChar(0xE0),
+        out.putChar((uchar)(val >> 56)),
+        out.putChar((uchar)(val >> 48)),
+        out.putChar((uchar)(val >> 40)),
+        out.putChar((uchar)(val >> 32)),
+        out.putChar((uchar)(val >> 24)),
+        out.putChar((uchar)(val >> 16)),
+        out.putChar((uchar)(val >> 8)),
+        out.putChar((uchar)val);
+}
+
+
+uint64 getUInt(File& in)
+    /* throw(Exception_EOF) */
+{
+    uint byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7;
+    byte0 = in.getChar();
+    if (byte0 == (uint)EOF)
+        throw Exception_EOF();
+    if (!(byte0 & 0x80))
+        return byte0;
+    else{
+        switch ((byte0 & 0x60) >> 5){
+        case 0:
+            byte1 = in.getChar();
+            return ((byte0 & 0x1F) << 8) | byte1;
+        case 1:
+            byte1 = in.getChar();
+            byte2 = in.getChar();
+            return ((byte0 & 0x1F) << 16) | (byte1 << 8) | byte2;
+        case 2:
+            byte1 = in.getChar();
+            byte2 = in.getChar();
+            byte3 = in.getChar();
+            return ((byte0 & 0x1F) << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
+        default:
+            byte0 = in.getChar();
+            byte1 = in.getChar();
+            byte2 = in.getChar();
+            byte3 = in.getChar();
+            byte4 = in.getChar();
+            byte5 = in.getChar();
+            byte6 = in.getChar();
+            byte7 = in.getChar();
+            return ((uint64)((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3) << 32)
+                 |  (uint64)((byte4 << 24) | (byte5 << 16) | (byte6 << 8) | byte7);
+        }
+    }
+}
diff -rupN ./File.h ..\Minisat/File.h
--- ./File.h	2014-02-26 14:57:06.983135000 +0000
+++ ..\Minisat/File.h	2011-02-02 14:34:26.247388000 +0000
@@ -5,13 +5,14 @@
 #include "Global.h"
 #endif
 
-#include <unistd.h>
+//#include <unistd.h>
+#include <io.h>
 #include <fcntl.h>
 #include <sys/stat.h>
 
 #ifndef _LARGEFILE64_SOURCE
-#define lseek64 ::lseek
-#define open64  ::open
+#define lseek64 ::_lseek
+#define open64  ::_open
 #endif
 
 
@@ -70,7 +71,7 @@ public:
         if (m == mode) return;
         if (m == READ){
             flush();
-            size = read(fd, buf, File_BufSize);
+            size = _read(fd, buf, File_BufSize);
         }else{
             lseek64(fd, pos - size, SEEK_CUR);
             size = -1; }
@@ -83,7 +84,7 @@ public:
       #endif
         if (pos < size) return (uchar)buf[pos++];
         if (size < File_BufSize) return EOF;
-        size = read(fd, buf, File_BufSize);
+        size = _read(fd, buf, File_BufSize);
         pos  = 0;
         if (size == 0) return EOF;
         return (uchar)buf[pos++]; }
@@ -93,7 +94,7 @@ public:
         assert(mode == WRITE);
       #endif
         if (pos == File_BufSize)
-            write(fd, buf, File_BufSize),
+            _write(fd, buf, File_BufSize),
             pos = 0;
         return buf[pos++] = (uchar)chr; }
 
@@ -109,14 +110,14 @@ public:
         assert(mode == READ);
         if (pos < size) return false;
         if (size < File_BufSize) return true;
-        size = read(fd, buf, File_BufSize);
+        size = _read(fd, buf, File_BufSize);
         pos  = 0;
         if (size == 0) return true;
         return false; }
 
     void flush(void) {
         assert(mode == WRITE);
-        write(fd, buf, pos);
+        _write(fd, buf, pos);
         pos = 0; }
 
     void  seek(int64 pos, int whence = SEEK_SET);
@@ -129,7 +130,7 @@ public:
 
 
 void                 putUInt (File& out, uint64 val);
-uint64               getUInt (File& in) throw(Exception_EOF);
+uint64               getUInt (File& in) /*throw(Exception_EOF)*/ ;
 static inline uint64 encode64(int64  val)           { return (val >= 0) ? (uint64)val << 1 : (((uint64)(~val) << 1) | 1); }
 static inline int64  decode64(uint64 val)           { return ((val & 1) == 0) ? (int64)(val >> 1) : ~(int64)(val >> 1); }
 static inline void   putInt  (File& out, int64 val) { putUInt(out, encode64(val)); }
diff -rupN ./Global.h ..\Minisat/Global.h
--- ./Global.h	2014-02-26 14:57:06.998758500 +0000
+++ ..\Minisat/Global.h	2012-07-22 21:51:12.383679600 +0100
@@ -1,274 +1,308 @@
-/****************************************************************************************[Global.h]
-MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-associated documentation files (the "Software"), to deal in the Software without restriction,
-including without limitation the rights to use, copy, modify, merge, publish, distribute,
-sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or
-substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
-OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
-
-#ifndef Global_h
-#define Global_h
-
-#include <cassert>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <climits>
-#include <cfloat>
-#include <new>
-
-
-//=================================================================================================
-// Basic Types & Minor Things:
-
-
-#ifdef _MSC_VER
-typedef INT64              int64;
-typedef UINT64             uint64;
-typedef INT_PTR            intp;
-typedef UINT_PTR           uintp;
-#define I64_fmt "I64d"
-#else
-typedef long long          int64;
-typedef unsigned long long uint64;
-typedef __PTRDIFF_TYPE__   intp;
-typedef unsigned __PTRDIFF_TYPE__ uintp;
-#define I64_fmt "lld"
-#endif
-typedef unsigned char uchar;
-typedef const char    cchar;
-
-
-template<class T> static inline T min(T x, T y) { return (x < y) ? x : y; }
-template<class T> static inline T max(T x, T y) { return (x > y) ? x : y; }
-
-template <bool> struct STATIC_ASSERTION_FAILURE;
-template <> struct STATIC_ASSERTION_FAILURE<true>{};
-#define TEMPLATE_FAIL STATIC_ASSERTION_FAILURE<false>()
-
-
-//=================================================================================================
-// 'malloc()'-style memory allocation -- never returns NULL; aborts instead:
-
-
-template<class T> static inline T* xmalloc(size_t size) {
-    T*   tmp = (T*)malloc(size * sizeof(T));
-    assert(size == 0 || tmp != NULL);
-    return tmp; }
-
-template<class T> static inline T* xrealloc(T* ptr, size_t size) {
-    T*   tmp = (T*)realloc((void*)ptr, size * sizeof(T));
-    assert(size == 0 || tmp != NULL);
-    return tmp; }
-
-template<class T> static inline void xfree(T *ptr) {
-    if (ptr != NULL) free((void*)ptr); }
-
-
-//=================================================================================================
-// Random numbers:
-
-
-// Returns a random float 0 <= x < 1. Seed must never be 0.
-static inline double drand(double& seed) {
-    seed *= 1389796;
-    int q = (int)(seed / 2147483647);
-    seed -= (double)q * 2147483647;
-    return seed / 2147483647; }
-
-// Returns a random integer 0 <= x < size. Seed must never be 0.
-static inline int irand(double& seed, int size) {
-    return (int)(drand(seed) * size); }
-
-
-//=================================================================================================
-// Time and Memory:
-
-
-//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-#ifdef _MSC_VER
-
-#include <ctime>
-
-static inline double cpuTime(void) {
-    return (double)clock() / CLOCKS_PER_SEC; }
-
-static inline int64 memUsed() {
-    return 0; }
-
-//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-#else
-
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <unistd.h>
-
-static inline double cpuTime(void) {
-    struct rusage ru;
-    getrusage(RUSAGE_SELF, &ru);
-    return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
-
-static inline int memReadStat(int field)
-{
-    char    name[256];
-    pid_t pid = getpid();
-    sprintf(name, "/proc/%d/statm", pid);
-    FILE*   in = fopen(name, "rb");
-    if (in == NULL) return 0;
-    int     value;
-    for (; field >= 0; field--)
-        fscanf(in, "%d", &value);
-    fclose(in);
-    return value;
-}
-
-static inline int64 memUsed() { return (int64)memReadStat(0) * (int64)getpagesize(); }
-
-//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-#endif
-
-
-
-//=================================================================================================
-// 'vec' -- automatically resizable arrays (via 'push()' method):
-
-
-// NOTE! Don't use this vector on datatypes that cannot be re-located in memory (with realloc)
-
-template<class T>
-class vec {
-    T*  data;
-    int sz;
-    int cap;
-
-    void     init(int size, const T& pad);
-    void     grow(int min_cap);
-
-public:
-    // Types:
-    typedef int Key;
-    typedef T   Datum;
-
-    // Constructors:
-    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }
-    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
-    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
-    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      // (takes ownership of array -- will be deallocated with 'xfree()')
-   ~vec(void)                                                      { clear(true); }
-
-    // Ownership of underlying array:
-    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }
-    operator T*       (void)           { return data; }     // (unsafe but convenient)
-    operator const T* (void) const     { return data; }
-
-    // Size operations:
-    int      size   (void) const       { return sz; }
-    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
-    void     pop    (void)             { sz--, data[sz].~T(); }
-    void     growTo (int size);
-    void     growTo (int size, const T& pad);
-    void     clear  (bool dealloc = false);
-    void     capacity (int size) { grow(size); }
-
-    // Stack interface:
-    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }
-    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }
-    const T& last  (void) const        { return data[sz-1]; }
-    T&       last  (void)              { return data[sz-1]; }
-
-    // Vector interface:
-    const T& operator [] (int index) const  { return data[index]; }
-    T&       operator [] (int index)        { return data[index]; }
-
-    // Don't allow copying (error prone):
-    vec<T>&  operator = (vec<T>& other) { TEMPLATE_FAIL; }
-             vec        (vec<T>& other) { TEMPLATE_FAIL; }
-
-    // Duplicatation (preferred instead):
-    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }
-    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
-};
-
-template<class T>
-void vec<T>::grow(int min_cap) {
-    if (min_cap <= cap) return;
-    if (cap == 0) cap = (min_cap >= 2) ? min_cap : 2;
-    else          do cap = (cap*3+1) >> 1; while (cap < min_cap);
-    data = xrealloc(data, cap); }
-
-template<class T>
-void vec<T>::growTo(int size, const T& pad) {
-    if (sz >= size) return;
-    grow(size);
-    for (int i = sz; i < size; i++) new (&data[i]) T(pad);
-    sz = size; }
-
-template<class T>
-void vec<T>::growTo(int size) {
-    if (sz >= size) return;
-    grow(size);
-    for (int i = sz; i < size; i++) new (&data[i]) T();
-    sz = size; }
-
-template<class T>
-void vec<T>::clear(bool dealloc) {
-    if (data != NULL){
-        for (int i = 0; i < sz; i++) data[i].~T();
-        sz = 0;
-        if (dealloc) xfree(data), data = NULL, cap = 0; } }
-
-
-//=================================================================================================
-// Lifted booleans:
-
-
-class lbool {
-    int     value;
-    explicit lbool(int v) : value(v) { }
-
-public:
-    lbool()       : value(0) { }
-    lbool(bool x) : value((int)x*2-1) { }
-    int toInt(void) const { return value; }
-
-    bool  operator == (const lbool& other) const { return value == other.value; }
-    bool  operator != (const lbool& other) const { return value != other.value; }
-    lbool operator ~  (void)               const { return lbool(-value); }
-
-    friend int   toInt  (lbool l);
-    friend lbool toLbool(int   v);
-};
-inline int   toInt  (lbool l) { return l.toInt(); }
-inline lbool toLbool(int   v) { return lbool(v);  }
-
-const lbool l_True  = toLbool( 1);
-const lbool l_False = toLbool(-1);
-const lbool l_Undef = toLbool( 0);
-
-
-//=================================================================================================
-// Relation operators -- extend definitions from '==' and '<'
-
-
-#ifndef __SGI_STL_INTERNAL_RELOPS   // (be aware of SGI's STL implementation...)
-#define __SGI_STL_INTERNAL_RELOPS
-template <class T> static inline bool operator != (const T& x, const T& y) { return !(x == y); }
-template <class T> static inline bool operator >  (const T& x, const T& y) { return y < x;     }
-template <class T> static inline bool operator <= (const T& x, const T& y) { return !(y < x);  }
-template <class T> static inline bool operator >= (const T& x, const T& y) { return !(x < y);  }
-#endif
-
-
-//=================================================================================================
-#endif
+/****************************************************************************************[Global.h]
+MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Global_h
+#define Global_h
+
+#ifdef _DEBUG
+  #define _CRTDBG_MAP_ALLOC
+  #define _CRTDBG_MAP_ALLOC_NEW
+  #include <stdlib.h>
+  #include <crtdbg.h>
+#endif
+
+#include <cassert>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <climits>
+#include <cfloat>
+#include <new>
+
+
+//=================================================================================================
+// Basic Types & Minor Things:
+
+
+#ifdef _MSC_VER
+typedef unsigned int       uint;
+typedef __int64            int64;
+typedef unsigned long long uint64;
+typedef int *              intp;
+typedef unsigned int *     uintp;
+#define I64_fmt "I64d"
+#else
+typedef long long          int64;
+typedef unsigned long long uint64;
+typedef __PTRDIFF_TYPE__   intp;
+typedef unsigned __PTRDIFF_TYPE__ uintp;
+#define I64_fmt "lld"
+#endif
+typedef unsigned char uchar;
+typedef const char    cchar;
+
+
+template<class T> static inline T min(T x, T y) { return (x < y) ? x : y; }
+template<class T> static inline T max(T x, T y) { return (x > y) ? x : y; }
+
+template <bool> struct STATIC_ASSERTION_FAILURE;
+template <> struct STATIC_ASSERTION_FAILURE<true>{};
+#define TEMPLATE_FAIL STATIC_ASSERTION_FAILURE<false>()
+
+
+//=================================================================================================
+// 'malloc()'-style memory allocation -- never returns NULL; aborts instead:
+
+#ifdef _COUNTED_ALLOCATION
+// CMW: this tracks the number of bytes allocated in mem[0].
+template<class T> static inline T* xmalloc(size_t size) {
+    T*   tmp = (T*)malloc(size * sizeof(T) + sizeof(size_t));
+    if (size > 0 && tmp==NULL) throw std::bad_alloc();
+    assert(size == 0 || tmp != NULL);
+    ((size_t*)tmp)[0] = size;
+    return (T*) (((size_t*)tmp) + 1); }
+
+template<class T> static inline T* xrealloc(T* ptr, size_t size) {
+    size_t * p = ((size_t*) ptr) - 1;
+    T*   tmp = (T*)realloc((void*)p, size * sizeof(T));
+    if (size > 0 && tmp==NULL) throw std::bad_alloc();
+    assert(size == 0 || tmp != NULL);
+    ((size_t*)tmp)[0] = size;
+    return (T*) (((size_t*)tmp) + 1); }
+
+template<class T> static inline void xfree(T *ptr) {
+    size_t * p = ((size_t*) ptr) - 1;
+    size_t size = *(p);
+    if (ptr != NULL) free((void*)p); }
+#else
+template<class T> static inline T* xmalloc(size_t size) {
+    T*   tmp = (T*)malloc(size * sizeof(T));
+    if (size > 0 && tmp==NULL) throw std::bad_alloc();
+    assert(size == 0 || tmp != NULL);
+    return tmp; }
+
+template<class T> static inline T* xrealloc(T* ptr, size_t size) {
+    T*   tmp = (T*)realloc((void*)ptr, size * sizeof(T));
+    if (size > 0 && tmp==NULL) throw std::bad_alloc();
+    assert(size == 0 || tmp != NULL);
+    return tmp; }
+
+template<class T> static inline void xfree(T *ptr) {
+    if (ptr != NULL) free((void*)ptr); }
+#endif
+
+
+//=================================================================================================
+// Random numbers:
+
+
+// Returns a random float 0 <= x < 1. Seed must never be 0.
+static inline double drand(double& seed) {
+    seed *= 1389796;
+    int q = (int)(seed / 2147483647);
+    seed -= (double)q * 2147483647;
+    return seed / 2147483647; }
+
+// Returns a random integer 0 <= x < size. Seed must never be 0.
+static inline int irand(double& seed, size_t size) {
+    return (int)(drand(seed) * size); }
+
+
+//=================================================================================================
+// Time and Memory:
+
+
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+#ifdef _MSC_VER
+
+#include <ctime>
+
+static inline double cpuTime(void) {
+    return (double)clock() / CLOCKS_PER_SEC; }
+
+static inline int64 memUsed() {
+    return 0; }
+
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+#else
+
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <unistd.h>
+
+static inline double cpuTime(void) {
+    struct rusage ru;
+    getrusage(RUSAGE_SELF, &ru);
+    return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
+
+static inline int memReadStat(int field)
+{
+    char    name[256];
+    pid_t pid = getpid();
+    sprintf(name, "/proc/%d/statm", pid);
+    FILE*   in = fopen(name, "rb");
+    if (in == NULL) return 0;
+    int     value;
+    for (; field >= 0; field--)
+        fscanf(in, "%d", &value);
+    fclose(in);
+    return value;
+}
+
+static inline int64 memUsed() { return (int64)memReadStat(0) * (int64)getpagesize(); }
+
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+#endif
+
+
+
+//=================================================================================================
+// 'vec' -- automatically resizable arrays (via 'push()' method):
+
+
+// NOTE! Don't use this vector on datatypes that cannot be re-located in memory (with realloc)
+
+template<class T>
+class vec {
+    T*  data;
+    int sz;
+    int cap;
+
+    void     init(int size, const T& pad);
+    void     grow(int min_cap);
+
+public:
+    // Types:
+    typedef int Key;
+    typedef T   Datum;
+
+    // Constructors:
+    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }
+    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
+    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
+    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      // (takes ownership of array -- will be deallocated with 'xfree()')
+   ~vec(void)                                                      { clear(true); }
+
+    // Ownership of underlying array:
+    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }
+    operator T*       (void)           { return data; }     // (unsafe but convenient)
+    operator const T* (void) const     { return data; }
+
+    // Size operations:
+    int      size   (void) const       { return sz; }
+    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
+    void     pop    (void)             { sz--, data[sz].~T(); }
+    void     growTo (int size);
+    void     growTo (int size, const T& pad);
+    void     clear  (bool dealloc = false);
+    void     capacity (int size) { grow(size); }
+
+    // Stack interface:
+    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }
+    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }
+    const T& last  (void) const        { return data[sz-1]; }
+    T&       last  (void)              { return data[sz-1]; }
+
+    // Vector interface:
+    const T& operator [] (int index) const  { return data[index]; }
+    T&       operator [] (int index)        { return data[index]; }
+
+    // Don't allow copying (error prone):
+    /*vec<T>&  operator = (vec<T>& other) { TEMPLATE_FAIL; }
+             vec        (vec<T>& other) { TEMPLATE_FAIL; }*/    
+    // CMW: Want copy constructor!
+    vec        (const vec<T>& other) : data(NULL), sz(0), cap(0) { for (int i=0;i<other.size();i++) push(other[i]); }    
+
+    // Duplicatation (preferred instead):
+    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }
+    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
+};
+
+template<class T>
+void vec<T>::grow(int min_cap) {
+    if (min_cap <= cap) return;
+    if (cap == 0) cap = (min_cap >= 2) ? min_cap : 2;
+    else          do cap = (cap*3+1) >> 1; while (cap < min_cap);
+    data = xrealloc(data, cap); }
+
+template<class T>
+void vec<T>::growTo(int  size, const T& pad) {
+    if (sz >= size) return;
+    grow(size);
+    for (int i = sz; i < size; i++) new (&data[i]) T(pad);
+    sz = size; }
+
+template<class T>
+void vec<T>::growTo(int size) {
+    if (sz >= size) return;
+    grow(size);
+    for (int i = sz; i < size; i++) new (&data[i]) T();
+    sz = size; }
+
+template<class T>
+void vec<T>::clear(bool dealloc) {
+    if (data != NULL){
+        for (int i = 0; i < sz; i++) data[i].~T();
+        sz = 0;
+        if (dealloc) xfree(data), data = NULL, cap = 0; } }
+
+
+//=================================================================================================
+// Lifted booleans:
+
+
+class lbool {
+    int     value;
+    explicit lbool(int v) : value(v) { }
+
+public:
+    lbool()       : value(0) { }
+    lbool(bool x) : value((int)x*2-1) { }
+    int toInt(void) const { return value; }
+
+    bool  operator == (const lbool& other) const { return value == other.value; }
+    bool  operator != (const lbool& other) const { return value != other.value; }
+    lbool operator ~  (void)               const { return lbool(-value); }
+
+    friend int   toInt  (lbool l);
+    friend lbool toLbool(int   v);
+};
+inline int   toInt  (lbool l) { return l.toInt(); }
+inline lbool toLbool(int   v) { return lbool(v);  }
+
+const lbool l_True  = toLbool( 1);
+const lbool l_False = toLbool(-1);
+const lbool l_Undef = toLbool( 0);
+
+
+//=================================================================================================
+// Relation operators -- extend definitions from '==' and '<'
+
+
+#ifndef __SGI_STL_INTERNAL_RELOPS   // (be aware of SGI's STL implementation...)
+#define __SGI_STL_INTERNAL_RELOPS
+template <class T> static inline bool operator != (const T& x, const T& y) { return !(x == y); }
+template <class T> static inline bool operator >  (const T& x, const T& y) { return y < x;     }
+template <class T> static inline bool operator <= (const T& x, const T& y) { return !(y < x);  }
+template <class T> static inline bool operator >= (const T& x, const T& y) { return !(x < y);  }
+#endif
+
+
+//=================================================================================================
+#endif
diff -rupN ./Minisat.vcxproj ..\Minisat/Minisat.vcxproj
--- ./Minisat.vcxproj	1970-01-01 00:00:00.000000000 +0000
+++ ..\Minisat/Minisat.vcxproj	2014-02-10 15:55:24.165710700 +0000
@@ -0,0 +1,164 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="File.cpp" />
+    <ClCompile Include="Proof.cpp" />
+    <ClCompile Include="Solver.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="File.h" />
+    <ClInclude Include="Global.h" />
+    <ClInclude Include="Heap.h" />
+    <ClInclude Include="Proof.h" />
+    <ClInclude Include="Solver.h" />
+    <ClInclude Include="SolverTypes.h" />
+    <ClInclude Include="Sort.h" />
+    <ClInclude Include="VarOrder.h" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{EC361209-6F93-496C-87C3-128660A1F598}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Minisat</RootNamespace>
+    <ProjectName>Minisat-p_1.14</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff -rupN ./Minisat.vcxproj.filters ..\Minisat/Minisat.vcxproj.filters
--- ./Minisat.vcxproj.filters	1970-01-01 00:00:00.000000000 +0000
+++ ..\Minisat/Minisat.vcxproj.filters	2011-02-02 19:46:13.922149700 +0000
@@ -0,0 +1,54 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="Solver.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="Sort.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="Global.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="Proof.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="File.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="Heap.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="SolverTypes.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="VarOrder.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="Solver.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="Proof.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="File.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff -rupN ./Proof.C ..\Minisat/Proof.C
--- ./Proof.C	2014-02-26 14:57:07.045632200 +0000
+++ ..\Minisat/Proof.C	1970-01-01 00:00:00.000000000 +0000
@@ -1,235 +0,0 @@
-/*****************************************************************************************[Proof.C]
-MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-associated documentation files (the "Software"), to deal in the Software without restriction,
-including without limitation the rights to use, copy, modify, merge, publish, distribute,
-sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or
-substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
-OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
-
-#include "Proof.h"
-#include "Sort.h"
-
-
-//=================================================================================================
-// Temporary files handling:
-
-
-class TempFiles {
-    vec<cchar*> files;      // For clean-up purposed on abnormal exit.
-
-public:
-   ~TempFiles()
-    {
-        for (int i = 0; i < files.size(); i++)
-            remove(files[i]);
-            //printf("Didn't delete:\n  %s\n", files[i]);
-    }
-
-    // Returns a read-only string with the filename of the temporary file. The pointer can be used to 
-    // remove the file (which is otherwise done automatically upon program exit).
-    //
-    char* open(File& fp)
-    {
-        char*   name;
-        for(;;){
-            name = tempnam(NULL, NULL);     // (gcc complains about this... stupid gcc...)
-            assert(name != NULL);
-            fp.open(name, "wx+");
-            if (fp.null())
-                xfree(name);
-            else{
-                files.push(name);
-                return name;
-            }
-        }
-    }
-};
-static TempFiles temp_files;       // (should be singleton)
-
-
-//=================================================================================================
-// Proof logging:
-
-
-Proof::Proof()
-{
-    fp_name    = temp_files.open(fp);
-    id_counter = 0;
-    trav       = NULL;
-}
-
-
-Proof::Proof(ProofTraverser& t)
-{
-    id_counter = 0;
-    trav       = &t;
-}
-
-
-ClauseId Proof::addRoot(vec<Lit>& cl)
-{
-    cl.copyTo(clause);
-    sortUnique(clause);
-
-    if (trav != NULL)
-        trav->root(clause);
-    if (!fp.null()){
-        putUInt(fp, index(clause[0]) << 1);
-        for (int i = 1; i < clause.size(); i++)
-            putUInt(fp, index(clause[i]) - index(clause[i-1]));
-        putUInt(fp, 0);     // (0 is safe terminator since we removed duplicates)
-    }
-
-    return id_counter++;
-}
-
-
-void Proof::beginChain(ClauseId start)
-{
-    assert(start != ClauseId_NULL);
-    chain_id .clear();
-    chain_var.clear();
-    chain_id.push(start);
-}
-
-
-void Proof::resolve(ClauseId next, Var x)
-{
-    assert(next != ClauseId_NULL);
-    chain_id .push(next);
-    chain_var.push(x);
-}
-
-
-ClauseId Proof::endChain()
-{
-    assert(chain_id.size() == chain_var.size() + 1);
-    if (chain_id.size() == 1)
-        return chain_id[0];
-    else{
-        if (trav != NULL)
-            trav->chain(chain_id, chain_var);
-        if (!fp.null()){
-            putUInt(fp, ((id_counter - chain_id[0]) << 1) | 1);
-            for (int i = 0; i < chain_var.size(); i++)
-                putUInt(fp, chain_var[i] + 1),
-                putUInt(fp, id_counter - chain_id[i+1]);
-            putUInt(fp, 0);
-        }
-
-        return id_counter++;
-    }
-}
-
-
-void Proof::deleted(ClauseId gone)
-{
-    if (trav != NULL)
-        trav->deleted(gone);
-    if (!fp.null()){
-        putUInt(fp, ((id_counter - gone) << 1) | 1);
-        putUInt(fp, 0);
-    }
-}
-
-
-//=================================================================================================
-// Read-back methods:
-
-
-void Proof::compress(Proof& dst, ClauseId goal)
-{
-    assert(!fp.null());
-    assert(false);  // Not yet!    
-}
-
-
-bool Proof::save(cchar* filename)
-{
-    assert(!fp.null());
-
-    // Switch to read mode:
-    fp.setMode(READ);
-    fp.seek(0);
-
-    // Copy file:
-    File    out(filename, "wox");
-    if (out.null())
-        return false;
-
-    while (!fp.eof())
-        out.putChar(fp.getChar());
-
-    // Restore write (proof-logging) mode:
-    fp.seek(0, SEEK_END);
-    fp.setMode(WRITE);
-    return true;
-}
-
-
-void Proof::traverse(ProofTraverser& trav, ClauseId goal)
-{
-    assert(!fp.null());
-
-    // Switch to read mode:
-    fp.setMode(READ);
-    fp.seek(0);
-
-    // Traverse proof:
-    if (goal == ClauseId_NULL)
-        goal = last();
-
-    uint64  tmp;
-    int     idx;
-    for(ClauseId id = 0; id <= goal; id++){
-        tmp = getUInt(fp);
-        if ((tmp & 1) == 0){
-            // Root clause:
-            clause.clear();
-            idx = tmp >> 1;
-            clause.push(toLit(idx));
-            for(;;){
-                tmp = getUInt(fp);
-                if (tmp == 0) break;
-                idx += tmp;
-                clause.push(toLit(idx));
-            }
-            trav.root(clause);
-
-        }else{
-            // Derivation or Deletion:
-            chain_id .clear();
-            chain_var.clear();
-            chain_id.push(id - (tmp >> 1));
-            for(;;){
-                tmp = getUInt(fp);
-                if (tmp == 0) break;
-                chain_var.push(tmp - 1);
-                tmp = getUInt(fp);
-                chain_id.push(id - tmp);
-            }
-
-            if (chain_var.size() == 0)
-                id--,   // (no new clause introduced)
-                trav.deleted(chain_id[0]);
-            else
-                trav.chain(chain_id, chain_var);
-        }
-    }
-    trav.done();
-
-    // Restore write (proof-logging) mode:
-    fp.seek(0, SEEK_END);
-    fp.setMode(WRITE);
-}
diff -rupN ./Proof.cpp ..\Minisat/Proof.cpp
--- ./Proof.cpp	1970-01-01 00:00:00.000000000 +0000
+++ ..\Minisat/Proof.cpp	2012-07-20 08:19:23.126783400 +0100
@@ -0,0 +1,237 @@
+/*****************************************************************************************[Proof.C]
+MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include "Proof.h"
+#include "Sort.h"
+
+
+//=================================================================================================
+// Temporary files handling:
+
+
+class TempFiles {
+    vec<cchar*> files;      // For clean-up purposed on abnormal exit.
+
+public:
+   ~TempFiles()
+    {
+        for (int i = 0; i < files.size(); i++)
+            remove(files[i]);
+            //printf("Didn't delete:\n  %s\n", files[i]);
+    }
+
+    // Returns a read-only string with the filename of the temporary file. The pointer can be used to 
+    // remove the file (which is otherwise done automatically upon program exit).
+    //
+    char* open(File& fp)
+    {
+        char*   name;
+        for(;;){
+            name = _tempnam(NULL, NULL);     // (gcc complains about this... stupid gcc...)
+            assert(name != NULL);
+            fp.open(name, "wx+");
+            if (fp.null())
+                xfree(name);
+            else{
+                files.push(name);
+                return name;
+            }
+        }
+    }
+};
+static TempFiles temp_files;       // (should be singleton)
+
+
+//=================================================================================================
+// Proof logging:
+
+
+Proof::Proof()
+{
+    fp_name    = temp_files.open(fp);
+    id_counter = 0;
+    trav       = NULL;
+}
+
+
+Proof::Proof(ProofTraverser& t)
+{
+    id_counter = 0;
+    trav       = &t;
+}
+
+
+ClauseId Proof::addRoot(vec<Lit>& cl)
+{
+    cl.copyTo(clause);
+    sortUnique(clause);
+
+    if (trav != NULL)
+        trav->root(clause);
+    if (!fp.null()){
+        putUInt(fp, index(clause[0]) << 1);
+        for (int i = 1; i < clause.size(); i++)
+            putUInt(fp, index(clause[i]) - index(clause[i-1]));
+        putUInt(fp, 0);     // (0 is safe terminator since we removed duplicates)
+    }
+
+    return id_counter++;
+}
+
+
+void Proof::beginChain(ClauseId start)
+{
+    assert(start != ClauseId_NULL);
+    chain_id .clear();
+    chain_lit.clear();
+    chain_id.push(start);
+}
+
+
+void Proof::resolve(ClauseId next, Lit x)
+{
+    assert(next != ClauseId_NULL);
+    chain_id .push(next);
+    chain_lit.push(x);
+}
+
+
+ClauseId Proof::endChain()
+{
+    assert(chain_id.size() == chain_lit.size() + 1);
+    if (chain_id.size() == 1)
+        return chain_id[0];
+    else{
+        if (trav != NULL)
+            trav->chain(chain_id, chain_lit);
+        if (!fp.null()){
+            putUInt(fp, ((id_counter - chain_id[0]) << 1) | 1);
+            for (int i = 0; i < chain_lit.size(); i++)
+                putUInt(fp, toDimacs(chain_lit[i])),
+                putUInt(fp, id_counter - chain_id[i+1]);
+            putUInt(fp, 0);
+        }
+
+        return id_counter++;
+    }
+}
+
+
+void Proof::deleted(ClauseId gone)
+{
+    if (trav != NULL)
+        trav->deleted(gone);
+    if (!fp.null()){
+        putUInt(fp, ((id_counter - gone) << 1) | 1);
+        putUInt(fp, 0);
+    }
+}
+
+
+//=================================================================================================
+// Read-back methods:
+
+
+void Proof::compress(Proof& dst, ClauseId goal)
+{
+    assert(!fp.null());
+    assert(false);  // Not yet!    
+}
+
+
+bool Proof::save(cchar* filename)
+{
+    assert(!fp.null());
+
+    // Switch to read mode:
+    fp.setMode(READ);
+    fp.seek(0);
+
+    // Copy file:
+    File    out(filename, "wox");
+    if (out.null())
+        return false;
+
+    while (!fp.eof())
+        out.putChar(fp.getChar());
+
+    // Restore write (proof-logging) mode:
+    fp.seek(0, SEEK_END);
+    fp.setMode(WRITE);
+    return true;
+}
+
+void Proof::traverse(ProofTraverser& trav, ClauseId goal)
+{
+    assert(!fp.null());
+
+    // Switch to read mode:
+    fp.setMode(READ);
+    fp.seek(0);
+
+    // Traverse proof:
+    if (goal == ClauseId_NULL)
+        goal = last();
+
+    uint64 tmp;
+    int     idx;
+    for(ClauseId id = 0; id <= goal; id++){
+        tmp = getUInt(fp);
+        if ((tmp & 1) == 0){
+            // Root clause:
+            clause.clear();
+            idx = (int)(tmp >> 1);
+            clause.push(toLit(idx));
+            for(;;){
+                tmp = getUInt(fp);
+                if (tmp == 0) break;
+                idx += (int)tmp;
+                clause.push(toLit(idx));
+            }
+            trav.root(clause);
+
+        }else{
+            // Derivation or Deletion:
+            chain_id .clear();
+            chain_lit.clear();
+            chain_id.push(id - ((int)tmp >> 1));
+            for(;;){
+                tmp = getUInt(fp);
+                if (tmp == 0) break;
+                bool sgn = tmp<0;
+                // CMW: because we need the phase of pivots... 
+                int v = (int) (sgn ? -(signed)tmp : tmp);
+                chain_lit.push(Lit( v, sgn));
+                tmp = getUInt(fp);
+                chain_id.push(id - (int)tmp);
+            }
+
+            if (chain_lit.size() == 0)
+                id--,   // (no new clause introduced)
+                trav.deleted(chain_id[0]);
+            else
+                trav.chain(chain_id, chain_lit);
+        }
+    }
+    trav.done();
+
+    // Restore write (proof-logging) mode:
+    fp.seek(0, SEEK_END);
+    fp.setMode(WRITE);
+}
diff -rupN ./Proof.h ..\Minisat/Proof.h
--- ./Proof.h	2014-02-26 14:57:06.811270200 +0000
+++ ..\Minisat/Proof.h	2012-07-20 08:19:23.126783400 +0100
@@ -1,71 +1,72 @@
-/*****************************************************************************************[Proof.h]
-MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-associated documentation files (the "Software"), to deal in the Software without restriction,
-including without limitation the rights to use, copy, modify, merge, publish, distribute,
-sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or
-substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
-OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
-
-#ifndef Proof_h
-#define Proof_h
-
-#include "SolverTypes.h"
-#include "File.h"
-
-
-//=================================================================================================
-
-
-// A "listner" for the proof. Proof events will be passed onto (online mode) or replayed to
-// (offline mode) this class.  Each call to 'root()' or 'chain()' produces a new clause. The first
-// clause has ID 0, the next 1 and so on. These are the IDs passed to 'chain()'s 'cs' parameter.
-//
-struct ProofTraverser {
-    virtual void root   (const vec<Lit>& c) {}
-    virtual void chain  (const vec<ClauseId>& cs, const vec<Var>& xs) {}
-    virtual void deleted(ClauseId c) {}
-    virtual void done   () {}
-    virtual ~ProofTraverser() {}
-};
-
-
-class Proof {
-    File            fp;
-    cchar*          fp_name;
-    ClauseId        id_counter;
-    ProofTraverser* trav;
-
-    vec<Lit>        clause;
-    vec<ClauseId>   chain_id;
-    vec<Var>        chain_var;
-
-public:
-    Proof();                        // Offline mode -- proof stored to a file, which can be saved, compressed, and/or traversed.
-    Proof(ProofTraverser& t);       // Online mode -- proof will not be stored.
-
-    ClauseId addRoot   (vec<Lit>& clause);
-    void     beginChain(ClauseId start);
-    void     resolve   (ClauseId next, Var x);
-    ClauseId endChain  ();
-    void     deleted   (ClauseId gone);
-    ClauseId last      () { assert(id_counter != ClauseId_NULL); return id_counter - 1; }
-
-    void     compress  (Proof& dst, ClauseId goal = ClauseId_NULL);     // 'dst' should be a newly constructed, empty proof.
-    bool     save      (cchar* filename);
-    void     traverse  (ProofTraverser& trav, ClauseId goal = ClauseId_NULL) ;
-};
-
-
-//=================================================================================================
-#endif
+/*****************************************************************************************[Proof.h]
+MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Proof_h
+#define Proof_h
+
+#include "SolverTypes.h"
+#include "File.h"
+
+
+//=================================================================================================
+
+
+// A "listner" for the proof. Proof events will be passed onto (online mode) or replayed to
+// (offline mode) this class.  Each call to 'root()' or 'chain()' produces a new clause. The first
+// clause has ID 0, the next 1 and so on. These are the IDs passed to 'chain()'s 'cs' parameter.
+//
+struct ProofTraverser {
+    virtual void root   (const vec<Lit>& c) {}
+    virtual void chain  (const vec<ClauseId>& cs, const vec<Lit>& xs) {}
+    virtual void deleted(ClauseId c) {}
+    virtual void done   () {}
+    virtual ~ProofTraverser() {}
+};
+
+
+class Proof {
+    File            fp;
+    cchar*          fp_name;
+    ClauseId        id_counter;
+    ProofTraverser* trav;
+
+    vec<Lit>        clause;
+    vec<ClauseId>   chain_id;
+    vec<Lit>        chain_lit; // CMW: need phase of pivot.
+
+public:
+    Proof();                        // Offline mode -- proof stored to a file, which can be saved, compressed, and/or traversed.
+    Proof(ProofTraverser& t);       // Online mode -- proof will not be stored.
+
+    ClauseId addRoot   (vec<Lit>& clause);
+    void     beginChain(ClauseId start);    
+    void     resolve   (ClauseId next, Lit x);
+    ClauseId endChain  ();
+    void     deleted   (ClauseId gone);
+    ClauseId last      () { assert(id_counter != ClauseId_NULL); return id_counter - 1; }
+
+    void     compress  (Proof& dst, ClauseId goal = ClauseId_NULL);     // 'dst' should be a newly constructed, empty proof.
+    bool     save      (cchar* filename);
+    void     traverse  (ProofTraverser& trav, ClauseId goal = ClauseId_NULL) ;
+
+};
+
+
+//=================================================================================================
+#endif
diff -rupN ./Solver.C ..\Minisat/Solver.C
--- ./Solver.C	2014-02-26 14:57:06.858131600 +0000
+++ ..\Minisat/Solver.C	1970-01-01 00:00:00.000000000 +0000
@@ -1,819 +0,0 @@
-/****************************************************************************************[Solver.C]
-MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-associated documentation files (the "Software"), to deal in the Software without restriction,
-including without limitation the rights to use, copy, modify, merge, publish, distribute,
-sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or
-substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
-OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
-
-#include "Solver.h"
-#include "Sort.h"
-#include <cmath>
-
-#define CC_MINIMIZATION
-
-
-//=================================================================================================
-// Helper functions:
-
-
-void removeWatch(vec<Clause*>& ws, Clause* elem)
-{
-    if (ws.size() == 0) return;     // (skip lists that are already cleared)
-    int j = 0;
-    for (; ws[j] != elem  ; j++) assert(j < ws.size());
-    for (; j < ws.size()-1; j++) ws[j] = ws[j+1];
-    ws.pop();
-}
-
-
-//=================================================================================================
-// Operations on clauses:
-
-
-/*_________________________________________________________________________________________________
-|
-|  newClause : (ps : const vec<Lit>&) (learnt : bool) (id : ClauseId)  ->  [void]
-|  
-|  Description:
-|    Allocate and add a new clause to the SAT solvers clause database. If a conflict is detected,
-|    the 'ok' flag is cleared and the solver is in an unusable state (must be disposed).
-|  
-|  Input:
-|    ps     - The new clause as a vector of literals.
-|    learnt - Is the clause a learnt clause? For learnt clauses, 'ps[0]' is assumed to be the
-|             asserting literal. An appropriate 'enqueue()' operation will be performed on this
-|             literal. One of the watches will always be on this literal, the other will be set to
-|             the literal with the highest decision level.
-|    id     - If logging proof, learnt clauses should be given an ID by caller.
-|  
-|  Effect:
-|    Activity heuristics are updated.
-|________________________________________________________________________________________________@*/
-void Solver::newClause(const vec<Lit>& ps_, bool learnt, ClauseId id)
-{
-    assert(learnt || id == ClauseId_NULL);
-    if (!ok) return;
-
-    vec<Lit>    qs;
-    if (!learnt){
-        assert(decisionLevel() == 0);
-        ps_.copyTo(qs);                     // Make a copy of the input vector.
-
-        // Remove duplicates:
-        sortUnique(qs);
-
-        // Check if clause is satisfied:
-        for (int i = 0; i < qs.size()-1; i++){
-            if (qs[i] == ~qs[i+1])
-                return; }
-        for (int i = 0; i < qs.size(); i++){
-            if (value(qs[i]) == l_True)
-                return; }
-
-        // Remove false literals:
-        int     i, j;
-        if (proof != NULL) proof->beginChain(proof->addRoot(qs));
-        for (i = j = 0; i < qs.size(); i++)
-            if (value(qs[i]) != l_False)
-                qs[j++] = qs[i];
-            else
-                if (proof != NULL) proof->resolve(unit_id[var(qs[i])], var(qs[i]));
-        qs.shrink(i - j);
-        if (proof != NULL) id = proof->endChain();
-    }
-    const vec<Lit>& ps = learnt ? ps_ : qs; // 'ps' is now the (possibly) reduced vector of literals.
-
-    if (ps.size() == 0){
-        ok = false;
-
-    }else if (ps.size() == 1){
-        // NOTE: If enqueue takes place at root level, the assignment will be lost in incremental use (it doesn't seem to hurt much though).
-        if (id != ClauseId_NULL)
-            unit_id[var(ps[0])] = id;
-        if (!enqueue(ps[0]))
-            ok = false;
-
-    }else{
-        // Allocate clause:
-        Clause* c   = Clause_new(learnt, ps, id);
-
-        if (learnt){
-            // Put the second watch on the literal with highest decision level:
-            int     max_i = 1;
-            int     max   = level[var(ps[1])];
-            for (int i = 2; i < ps.size(); i++)
-                if (level[var(ps[i])] > max)
-                    max   = level[var(ps[i])],
-                    max_i = i;
-            (*c)[1]     = ps[max_i];
-            (*c)[max_i] = ps[1];
-
-            // Bumping:
-            claBumpActivity(c); // (newly learnt clauses should be considered active)
-
-            // Enqueue asserting literal:
-            check(enqueue((*c)[0], c));
-
-            // Store clause:
-            watches[index(~(*c)[0])].push(c);
-            watches[index(~(*c)[1])].push(c);
-            learnts.push(c);
-            stats.learnts_literals += c->size();
-
-        }else{
-            // Store clause:
-            watches[index(~(*c)[0])].push(c);
-            watches[index(~(*c)[1])].push(c);
-            clauses.push(c);
-            stats.clauses_literals += c->size();
-        }
-    }
-}
-
-
-// Disposes a clauses and removes it from watcher lists. NOTE! Low-level; does NOT change the 'clauses' and 'learnts' vector.
-//
-void Solver::remove(Clause* c, bool just_dealloc)
-{
-    if (!just_dealloc){
-        removeWatch(watches[index(~(*c)[0])], c),
-        removeWatch(watches[index(~(*c)[1])], c);
-
-        if (c->learnt()) stats.learnts_literals -= c->size();
-        else             stats.clauses_literals -= c->size();
-
-        if (proof != NULL) proof->deleted(c->id());
-    }
-
-    xfree(c);
-}
-
-
-// Can assume everything has been propagated! (esp. the first two literals are != l_False, unless
-// the clause is binary and satisfied, in which case the first literal is true)
-// Returns True if clause is satisfied (will be removed), False otherwise.
-//
-bool Solver::simplify(Clause* c) const
-{
-    assert(decisionLevel() == 0);
-    for (int i = 0; i < c->size(); i++){
-        if (value((*c)[i]) == l_True)
-            return true;
-    }
-    return false;
-}
-
-
-//=================================================================================================
-// Minor methods:
-
-
-// Creates a new SAT variable in the solver. If 'decision_var' is cleared, variable will not be
-// used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
-//
-Var Solver::newVar() {
-    int     index;
-    index = nVars();
-    watches     .push();          // (list for positive literal)
-    watches     .push();          // (list for negative literal)
-    reason      .push(NULL);
-    assigns     .push(toInt(l_Undef));
-    level       .push(-1);
-    trail_pos   .push(-1);
-    activity    .push(0);
-    order       .newVar();
-    analyze_seen.push(0);
-    if (proof != NULL) unit_id.push(ClauseId_NULL);
-    return index; }
-
-
-// Returns FALSE if immediate conflict.
-bool Solver::assume(Lit p) {
-    trail_lim.push(trail.size());
-    return enqueue(p); }
-
-
-// Revert to the state at given level.
-void Solver::cancelUntil(int level) {
-    if (decisionLevel() > level){
-        for (int c = trail.size()-1; c >= trail_lim[level]; c--){
-            Var     x  = var(trail[c]);
-            assigns[x] = toInt(l_Undef);
-            reason [x] = NULL;
-            order.undo(x); }
-        trail.shrink(trail.size() - trail_lim[level]);
-        trail_lim.shrink(trail_lim.size() - level);
-        qhead = trail.size(); } }
-
-
-//=================================================================================================
-// Major methods:
-
-
-/*_________________________________________________________________________________________________
-|
-|  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
-|  
-|  Description:
-|    Analyze conflict and produce a reason clause ('out_learnt') and a backtracking level
-|    ('out_btlevel').
-|  
-|    Pre-conditions:
-|      * 'out_learnt' is assumed to be cleared.
-|      * Current decision level must be greater than root level.
-|  
-|    Post-conditions:
-|      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
-|      * If performing proof-logging, the last derived clause in the proof is the reason clause.
-|________________________________________________________________________________________________@*/
-
-class lastToFirst_lt {  // Helper class to 'analyze' -- order literals from last to first occurance in 'trail[]'.
-    const vec<int>& trail_pos;
-public:
-    lastToFirst_lt(const vec<int>& t) : trail_pos(t) {}
-    bool operator () (Lit p, Lit q) { return trail_pos[var(p)] > trail_pos[var(q)]; }
-};
-
-void Solver::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)
-{
-    vec<char>&     seen  = analyze_seen;
-    int            pathC = 0;
-    Lit            p     = lit_Undef;
-
-    // Generate conflict clause:
-    //
-    if (proof != NULL) proof->beginChain(confl->id());
-    out_learnt.push();          // (leave room for the asserting literal)
-    out_btlevel = 0;
-    int index = trail.size()-1;
-    for(;;){
-        assert(confl != NULL);  // (otherwise should be UIP)
-
-        Clause& c = *confl;
-        if (c.learnt())
-            claBumpActivity(&c);
-
-        for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
-            Lit q = c[j];
-            if (!seen[var(q)]){
-                if (level[var(q)] > 0){
-                    varBumpActivity(q);
-                    seen[var(q)] = 1;
-                    if (level[var(q)] == decisionLevel())
-                        pathC++;
-                    else{
-                        out_learnt.push(q);
-                        out_btlevel = max(out_btlevel, level[var(q)]);
-                    }
-                }else
-                    if (proof != NULL) proof->resolve(unit_id[var(q)], var(q));
-            }
-        }
-
-        // Select next clause to look at:
-        while (!seen[var(trail[index--])]);
-        p     = trail[index+1];
-        confl = reason[var(p)];
-        seen[var(p)] = 0;
-        pathC--;
-        if (pathC == 0) break;
-
-        if (proof != NULL) proof->resolve(confl->id(), var(p));
-    }
-    out_learnt[0] = ~p;
-
-    // Conflict clause minimization:
-    //
-#ifdef CC_MINIMIZATION
-    int     i, j;
-    if (expensive_ccmin){
-        // Simplify conflict clause (a lot):
-        //
-        uint    min_level = 0;
-        for (i = 1; i < out_learnt.size(); i++)
-            min_level |= 1 << (level[var(out_learnt[i])] & 31);         // (maintain an abstraction of levels involved in conflict)
-
-        analyze_toclear.clear();
-        for (i = j = 1; i < out_learnt.size(); i++)
-            if (reason[var(out_learnt[i])] == NULL || !analyze_removable(out_learnt[i], min_level))
-                out_learnt[j++] = out_learnt[i];
-    }else{
-        // Simplify conflict clause (a little):
-        //
-        analyze_toclear.clear();
-        for (i = j = 1; i < out_learnt.size(); i++){
-            Clause* r = reason[var(out_learnt[i])];
-            if (r == NULL)
-                out_learnt[j++] = out_learnt[i];
-            else{
-                Clause& c = *r;
-                for (int k = 1; k < c.size(); k++)
-                    if (!seen[var(c[k])] && level[var(c[k])] != 0){
-                        out_learnt[j++] = out_learnt[i];
-                        goto Keep;
-                    }
-                analyze_toclear.push(out_learnt[i]);
-              Keep:;
-            }
-        }
-    }
-#else
-    int i = 0, j = 0;
-#endif
-
-    // Finilize proof logging with conflict clause minimization steps:
-    //
-    if (proof != NULL){
-        sort(analyze_toclear, lastToFirst_lt(trail_pos));
-        for (int k = 0; k < analyze_toclear.size(); k++){
-            Var     v = var(analyze_toclear[k]); assert(level[v] > 0);
-            Clause& c = *reason[v];
-            proof->resolve(c.id(), v);
-            for (int k = 1; k < c.size(); k++)
-                if (level[var(c[k])] == 0)
-                    proof->resolve(unit_id[var(c[k])], var(c[k]));
-        }
-        proof->endChain();
-    }
-    // Clean up:
-    //
-    for (int j = 0; j < out_learnt.size()     ; j++) seen[var(out_learnt     [j])] = 0;
-    for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
-
-    stats.max_literals += out_learnt.size();
-    out_learnt.shrink(i - j);
-    stats.tot_literals += out_learnt.size();
-}
-
-
-// Check if 'p' can be removed. 'min_level' is used to abort early if visiting literals at a level that cannot be removed.
-//
-bool Solver::analyze_removable(Lit p, uint min_level)
-{
-    assert(reason[var(p)] != NULL);
-    analyze_stack.clear(); analyze_stack.push(p);
-    int top = analyze_toclear.size();
-    while (analyze_stack.size() > 0){
-        assert(reason[var(analyze_stack.last())] != NULL);
-        Clause& c = *reason[var(analyze_stack.last())];
-        analyze_stack.pop();
-        for (int i = 1; i < c.size(); i++){
-            Lit p = c[i];
-            if (!analyze_seen[var(p)] && level[var(p)] != 0){
-                if (reason[var(p)] != NULL && ((1 << (level[var(p)] & 31)) & min_level) != 0){
-                    analyze_seen[var(p)] = 1;
-                    analyze_stack.push(p);
-                    analyze_toclear.push(p);
-                }else{
-                    for (int j = top; j < analyze_toclear.size(); j++)
-                        analyze_seen[var(analyze_toclear[j])] = 0;
-                    analyze_toclear.shrink(analyze_toclear.size() - top);
-                    return false;
-                }
-            }
-        }
-    }
-    analyze_toclear.push(p);
-
-    return true;
-}
-
-
-/*_________________________________________________________________________________________________
-|
-|  analyzeFinal : (confl : Clause*) (skip_first : bool)  ->  [void]
-|  
-|  Description:
-|    Specialized analysis procedure to express the final conflict in terms of assumptions.
-|    'root_level' is allowed to point beyond end of trace (useful if called after conflict while
-|    making assumptions). If 'skip_first' is TRUE, the first literal of 'confl' is  ignored (needed
-|    if conflict arose before search even started).
-|________________________________________________________________________________________________@*/
-void Solver::analyzeFinal(Clause* confl, bool skip_first)
-{
-    // -- NOTE! This code is relatively untested. Please report bugs!
-    conflict.clear();
-    if (root_level == 0){
-        if (proof != NULL) conflict_id = proof->last();
-        return; }
-
-    vec<char>&     seen  = analyze_seen;
-    if (proof != NULL) proof->beginChain(confl->id());
-    for (int i = skip_first ? 1 : 0; i < confl->size(); i++){
-        Var     x = var((*confl)[i]);
-        if (level[x] > 0)
-            seen[x] = 1;
-        else
-            if (proof != NULL) proof->resolve(unit_id[x], x);
-    }
-
-    int     start = (root_level >= trail_lim.size()) ? trail.size()-1 : trail_lim[root_level];
-    for (int i = start; i >= trail_lim[0]; i--){
-        Var     x = var(trail[i]);
-        if (seen[x]){
-            Clause* r = reason[x];
-            if (r == NULL){
-                assert(level[x] > 0);
-                conflict.push(~trail[i]);
-            }else{
-                Clause& c = *r;
-                if (proof != NULL) proof->resolve(c.id(), x);
-                for (int j = 1; j < c.size(); j++)
-                    if (level[var(c[j])] > 0)
-                        seen[var(c[j])] = 1;
-                    else
-                        if (proof != NULL) proof->resolve(unit_id[var(c[j])], var(c[j]));
-            }
-            seen[x] = 0;
-        }
-    }
-    if (proof != NULL) conflict_id = proof->endChain();
-}
-
-
-/*_________________________________________________________________________________________________
-|
-|  enqueue : (p : Lit) (from : Clause*)  ->  [bool]
-|  
-|  Description:
-|    Puts a new fact on the propagation queue as well as immediately updating the variable's value.
-|    Should a conflict arise, FALSE is returned.
-|  
-|  Input:
-|    p    - The fact to enqueue
-|    from - [Optional] Fact propagated from this (currently) unit clause. Stored in 'reason[]'.
-|           Default value is NULL (no reason).
-|  
-|  Output:
-|    TRUE if fact was enqueued without conflict, FALSE otherwise.
-|________________________________________________________________________________________________@*/
-bool Solver::enqueue(Lit p, Clause* from)
-{
-    if (value(p) != l_Undef)
-        return value(p) != l_False;
-    else{
-        Var     x = var(p);
-        assigns  [x] = toInt(lbool(!sign(p)));
-        level    [x] = decisionLevel();
-        trail_pos[x] = trail.size();
-        reason   [x] = from;
-        trail.push(p);
-        return true;
-    }
-}
-
-
-
-/*_________________________________________________________________________________________________
-|
-|  propagate : [void]  ->  [Clause*]
-|  
-|  Description:
-|    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
-|    otherwise NULL. NOTE! This method has been optimized for speed rather than readability.
-|  
-|    Post-conditions:
-|      * The propagation queue is empty, even if there was a conflict.
-|________________________________________________________________________________________________@*/
-Clause* Solver::propagate()
-{
-    Clause* confl = NULL;
-    while (qhead < trail.size()){
-        stats.propagations++;
-        simpDB_props--;
-
-        Lit            p  = trail[qhead++];     // 'p' is enqueued fact to propagate.
-        vec<Clause*>&  ws = watches[index(p)];
-        Clause**       i,** j,** end;
-
-        for (i = j = (Clause**)ws, end = i + ws.size();  i != end;){
-            Clause& c = **i; i++;
-            // Make sure the false literal is data[1]:
-            Lit false_lit = ~p;
-            if (c[0] == false_lit)
-                c[0] = c[1], c[1] = false_lit;
-
-            assert(c[1] == false_lit);
-
-            // If 0th watch is true, then clause is already satisfied.
-            Lit   first = c[0];
-            lbool val   = value(first);
-            if (val == l_True){
-                *j++ = &c;
-            }else{
-                // Look for new watch:
-                for (int k = 2; k < c.size(); k++)
-                    if (value(c[k]) != l_False){
-                        c[1] = c[k]; c[k] = false_lit;
-                        watches[index(~c[1])].push(&c);
-                        goto FoundWatch; }
-
-                // Did not find watch -- clause is unit under assignment:
-                if (decisionLevel() == 0 && proof != NULL){
-                    // Log the production of this unit clause:
-                    proof->beginChain(c.id());
-                    for (int k = 1; k < c.size(); k++)
-                        proof->resolve(unit_id[var(c[k])], var(c[k]));
-                    ClauseId id = proof->endChain();
-                    assert(unit_id[var(first)] == ClauseId_NULL || value(first) == l_False);    // (if variable already has 'id', it must be with the other polarity and we should have derived the empty clause here)
-                    if (value(first) != l_False)
-                        unit_id[var(first)] = id;
-                    else{
-                        // Empty clause derived:
-                        proof->beginChain(unit_id[var(first)]);
-                        proof->resolve(id, var(first));
-                        proof->endChain();
-                    }
-                }
-
-                *j++ = &c;
-                if (!enqueue(first, &c)){
-                    if (decisionLevel() == 0)
-                        ok = false;
-                    confl = &c;
-                    qhead = trail.size();
-                    // Copy the remaining watches:
-                    while (i < end)
-                        *j++ = *i++;
-                }
-              FoundWatch:;
-            }
-        }
-        ws.shrink(i - j);
-    }
-
-    return confl;
-}
-
-
-/*_________________________________________________________________________________________________
-|
-|  reduceDB : ()  ->  [void]
-|  
-|  Description:
-|    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
-|    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
-|________________________________________________________________________________________________@*/
-struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };
-void Solver::reduceDB()
-{
-    int     i, j;
-    double  extra_lim = cla_inc / learnts.size();    // Remove any clause below this activity
-
-    sort(learnts, reduceDB_lt());
-    for (i = j = 0; i < learnts.size() / 2; i++){
-        if (learnts[i]->size() > 2 && !locked(learnts[i]))
-            remove(learnts[i]);
-        else
-            learnts[j++] = learnts[i];
-    }
-    for (; i < learnts.size(); i++){
-        if (learnts[i]->size() > 2 && !locked(learnts[i]) && learnts[i]->activity() < extra_lim)
-            remove(learnts[i]);
-        else
-            learnts[j++] = learnts[i];
-    }
-    learnts.shrink(i - j);
-}
-
-
-/*_________________________________________________________________________________________________
-|
-|  simplifyDB : [void]  ->  [bool]
-|  
-|  Description:
-|    Simplify the clause database according to the current top-level assigment. Currently, the only
-|    thing done here is the removal of satisfied clauses, but more things can be put here.
-|________________________________________________________________________________________________@*/
-void Solver::simplifyDB()
-{
-    if (!ok) return;    // GUARD (public method)
-    assert(decisionLevel() == 0);
-
-    if (propagate() != NULL){
-        ok = false;
-        return; }
-
-    if (nAssigns() == simpDB_assigns || simpDB_props > 0)   // (nothing has changed or preformed a simplification too recently)
-        return;
-
-    // Clear watcher lists:
-    for (int i = simpDB_assigns; i < nAssigns(); i++){
-        Lit p = trail[i];
-        watches[index( p)].clear(true);
-        watches[index(~p)].clear(true);
-    }
-
-    // Remove satisfied clauses:
-    for (int type = 0; type < 2; type++){
-        vec<Clause*>& cs = type ? learnts : clauses;
-        int           j  = 0;
-        for (int i = 0; i < cs.size(); i++){
-            if (!locked(cs[i]) && simplify(cs[i]))
-                remove(cs[i]);
-            else
-                cs[j++] = cs[i];
-        }
-        cs.shrink(cs.size()-j);
-    }
-
-    simpDB_assigns = nAssigns();
-    simpDB_props   = stats.clauses_literals + stats.learnts_literals;   // (shouldn't depend on 'stats' really, but it will do for now)
-}
-
-
-/*_________________________________________________________________________________________________
-|
-|  search : (nof_conflicts : int) (nof_learnts : int) (params : const SearchParams&)  ->  [lbool]
-|  
-|  Description:
-|    Search for a model the specified number of conflicts, keeping the number of learnt clauses
-|    below the provided limit. NOTE! Use negative value for 'nof_conflicts' or 'nof_learnts' to
-|    indicate infinity.
-|  
-|  Output:
-|    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
-|    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
-|    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
-|________________________________________________________________________________________________@*/
-lbool Solver::search(int nof_conflicts, int nof_learnts, const SearchParams& params)
-{
-    if (!ok) return l_False;    // GUARD (public method)
-    assert(root_level == decisionLevel());
-
-    stats.starts++;
-    int     conflictC = 0;
-    var_decay = 1 / params.var_decay;
-    cla_decay = 1 / params.clause_decay;
-    model.clear();
-
-    for (;;){
-        Clause* confl = propagate();
-        if (confl != NULL){
-            // CONFLICT
-
-            stats.conflicts++; conflictC++;
-            vec<Lit>    learnt_clause;
-            int         backtrack_level;
-            if (decisionLevel() == root_level){
-                // Contradiction found:
-                analyzeFinal(confl);
-                return l_False; }
-            analyze(confl, learnt_clause, backtrack_level);
-            cancelUntil(max(backtrack_level, root_level));
-            newClause(learnt_clause, true, (proof != NULL) ? proof->last() : ClauseId_NULL);
-            if (learnt_clause.size() == 1) level[var(learnt_clause[0])] = 0;    // (this is ugly (but needed for 'analyzeFinal()') -- in future versions, we will backtrack past the 'root_level' and redo the assumptions)
-            varDecayActivity();
-            claDecayActivity();
-
-        }else{
-            // NO CONFLICT
-
-            if (nof_conflicts >= 0 && conflictC >= nof_conflicts){
-                // Reached bound on number of conflicts:
-                progress_estimate = progressEstimate();
-                cancelUntil(root_level);
-                return l_Undef; }
-
-            if (decisionLevel() == 0)
-                // Simplify the set of problem clauses:
-                simplifyDB(), assert(ok);
-
-            if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
-                // Reduce the set of learnt clauses:
-                reduceDB();
-
-            // New variable decision:
-            stats.decisions++;
-            Var next = order.select(params.random_var_freq);
-
-            if (next == var_Undef){
-                // Model found:
-                model.growTo(nVars());
-                for (int i = 0; i < nVars(); i++) model[i] = value(i);
-                cancelUntil(root_level);
-                return l_True;
-            }
-
-            check(assume(~Lit(next)));
-        }
-    }
-}
-
-
-// Return search-space coverage. Not extremely reliable.
-//
-double Solver::progressEstimate()
-{
-    double  progress = 0;
-    double  F = 1.0 / nVars();
-    for (int i = 0; i < nVars(); i++)
-        if (value(i) != l_Undef)
-            progress += pow(F, level[i]);
-    return progress / nVars();
-}
-
-
-// Divide all variable activities by 1e100.
-//
-void Solver::varRescaleActivity()
-{
-    for (int i = 0; i < nVars(); i++)
-        activity[i] *= 1e-100;
-    var_inc *= 1e-100;
-}
-
-
-// Divide all constraint activities by 1e100.
-//
-void Solver::claRescaleActivity()
-{
-    for (int i = 0; i < learnts.size(); i++)
-        learnts[i]->activity() *= 1e-20;
-    cla_inc *= 1e-20;
-}
-
-
-/*_________________________________________________________________________________________________
-|
-|  solve : (assumps : const vec<Lit>&)  ->  [bool]
-|  
-|  Description:
-|    Top-level solve. If using assumptions (non-empty 'assumps' vector), you must call
-|    'simplifyDB()' first to see that no top-level conflict is present (which would put the solver
-|    in an undefined state).
-|  
-|  Input:
-|    A list of assumptions (unit clauses coded as literals). Pre-condition: The assumptions must
-|    not contain both 'x' and '~x' for any variable 'x'.
-|________________________________________________________________________________________________@*/
-bool Solver::solve(const vec<Lit>& assumps)
-{
-    simplifyDB();
-    if (!ok) return false;
-
-    SearchParams    params(default_params);
-    double  nof_conflicts = 100;
-    double  nof_learnts   = nClauses() / 3;
-    lbool   status        = l_Undef;
-
-    // Perform assumptions:
-    root_level = assumps.size();
-    for (int i = 0; i < assumps.size(); i++){
-        Lit p = assumps[i];
-        assert(var(p) < nVars());
-        if (!assume(p)){
-            if (reason[var(p)] != NULL){
-                analyzeFinal(reason[var(p)], true);
-                conflict.push(~p);
-            }else{
-                assert(proof == NULL || unit_id[var(p)] != ClauseId_NULL);   // (this is the pre-condition above)
-                conflict.clear();
-                conflict.push(~p);
-                if (proof != NULL) conflict_id = unit_id[var(p)];
-            }
-            cancelUntil(0);
-            return false; }
-        Clause* confl = propagate();
-        if (confl != NULL){
-            analyzeFinal(confl), assert(conflict.size() > 0);
-            cancelUntil(0);
-            return false; }
-    }
-    assert(root_level == decisionLevel());
-
-    // Search:
-    if (verbosity >= 1){
-        reportf("==================================[MINISAT]===================================\n");
-        reportf("| Conflicts |     ORIGINAL     |              LEARNT              | Progress |\n");
-        reportf("|           | Clauses Literals |   Limit Clauses Literals  Lit/Cl |          |\n");
-        reportf("==============================================================================\n");
-    }
-
-    while (status == l_Undef){
-        if (verbosity >= 1){
-            reportf("| %9d | %7d %8d | %7d %7d %8d %7.1f | %6.3f %% |\n", (int)stats.conflicts, nClauses(), (int)stats.clauses_literals, (int)nof_learnts, nLearnts(), (int)stats.learnts_literals, (double)stats.learnts_literals/nLearnts(), progress_estimate*100);
-            fflush(stdout);
-        }
-        status = search((int)nof_conflicts, (int)nof_learnts, params);
-        nof_conflicts *= 1.5;
-        nof_learnts   *= 1.1;
-    }
-    if (verbosity >= 1)
-        reportf("==============================================================================\n");
-
-    cancelUntil(0);
-    return status == l_True;
-}
diff -rupN ./Solver.cpp ..\Minisat/Solver.cpp
--- ./Solver.cpp	1970-01-01 00:00:00.000000000 +0000
+++ ..\Minisat/Solver.cpp	2012-07-27 16:51:03.546897600 +0100
@@ -0,0 +1,1411 @@
+/****************************************************************************************[Solver.C]
+MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include <iostream>
+
+#include "Solver.h"
+#include "Sort.h"
+#include <cmath>
+#include <iostream>
+
+#define CC_MINIMIZATION
+
+//=================================================================================================
+// Helper functions:
+
+
+void removeWatch(vec<Clause*>& ws, Clause* elem)
+{  
+    if (ws.size() == 0) return;     // (skip lists that are already cleared)
+    int j = 0;
+    for (; ws[j] != elem ; j++) { assert(j < ws.size()); }    
+    for (; j < ws.size()-1; j++) ws[j] = ws[j+1];
+    ws.pop();
+}
+
+//=================================================================================================
+// Operations on clauses:
+
+
+/*_________________________________________________________________________________________________
+|
+|  newClause : (ps : const vec<Lit>&) (learnt : bool) (id : ClauseId)  ->  [void]
+|  
+|  Description:
+|    Allocate and add a new clause to the SAT solvers clause database. If a conflict is detected,
+|    the 'ok' flag is cleared and the solver is in an unusable state (must be disposed).
+|  
+|  Input:
+|    ps     - The new clause as a vector of literals.
+|    learnt - Is the clause a learnt clause? For learnt clauses, 'ps[0]' is assumed to be the
+|             asserting literal. An appropriate 'enqueue()' operation will be performed on this
+|             literal. One of the watches will always be on this literal, the other will be set to
+|             the literal with the highest decision level.
+|    id     - If logging proof, learnt clauses should be given an ID by caller.
+|  
+|  Effect:
+|    Activity heuristics are updated.
+|________________________________________________________________________________________________@*/
+void Solver::newClause(const vec<Lit>& ps_, bool learnt, ClauseId id, bool enqueue_asserting, bool halflearnt)
+{
+    assert(learnt || id == ClauseId_NULL);
+    if (!ok) return;
+
+    vec<Lit>    qs;
+    if (!learnt){
+        assert(decisionLevel() == 0);
+        ps_.copyTo(qs);                     // Make a copy of the input vector.
+
+        // Remove duplicates:
+        sortUnique(qs);
+
+        // Check if clause is satisfied:
+        for (int i = 0; i < qs.size()-1; i++){
+            if (qs[i] == ~qs[i+1])
+                return; }
+        for (int i = 0; i < qs.size(); i++){
+            if (value(qs[i]) == l_True)
+                return; }
+
+        // Remove false literals:
+        int     i, j;
+        if (proof != NULL) proof->beginChain(proof->addRoot(qs));
+        for (i = j = 0; i < qs.size(); i++)
+            if (value(qs[i]) != l_False)
+                qs[j++] = qs[i];
+            else
+            {
+              //std::cout << "removing " << (sign(qs[i])?"-":"") << var(qs[i]) << std::endl;
+                // CMW: Need phase of pivot.
+                //if (proof != NULL) proof->resolve(unit_id[var(qs[i])], var(qs[i]));
+                if (proof != NULL) proof->resolve(unit_id[var(qs[i])], qs[i]);
+            }
+        qs.shrink(i - j);
+        if (proof != NULL) id = proof->endChain();
+    }
+    const vec<Lit>& ps = learnt ? ps_ : qs; // 'ps' is now the (possibly) reduced vector of literals.
+
+    if (ps.size() == 0){
+        ok = false;
+
+    }else if (ps.size() == 1){
+      //std::cout << "LEARNED UNIT: " << (sign(ps[0])?"-":"") << var(ps[0]) << std::endl;
+        // NOTE: If enqueue takes place at root level, the assignment will be lost in incremental use (it doesn't seem to hurt much though).
+        if (id != ClauseId_NULL)
+            unit_id[var(ps[0])] = id;
+        if (!enqueue(ps[0]))
+            ok = false;
+    }else{
+        // Allocate clause:
+
+#ifdef _MEMORY_ALLOCATION
+		Clause* c   = Clause_new(learnt, ps, memory_counter, memory_limit, id);        
+#else
+		Clause* c   = Clause_new(learnt, ps, id);        
+#endif
+        if (learnt){
+            // Put the second watch on the literal with highest decision level:
+            int     max_i = 1;
+            int     max   = level[var(ps[1])];
+            for (int i = 2; i < ps.size(); i++)
+                if (level[var(ps[i])] > max)
+                    max   = level[var(ps[i])],
+                    max_i = i;
+            (*c)[1]     = ps[max_i];
+            (*c)[max_i] = ps[1];
+
+            // Bumping:
+            claBumpActivity(c); // (newly learnt clauses should be considered active)
+
+            // Enqueue asserting literal:
+            if (enqueue_asserting)
+              check(enqueue((*c)[0], c));
+
+            // Store clause:
+            watches[index(~(*c)[0])].push(c);
+            watches[index(~(*c)[1])].push(c);
+			if(halflearnt) halflearnts.push(c); 
+			else learnts.push(c);
+            stats.learnts_literals += c->size();
+
+		}else{
+            // Store clause:
+            watches[index(~(*c)[0])].push(c);
+            watches[index(~(*c)[1])].push(c);
+            clauses.push(c);
+            stats.clauses_literals += c->size();
+        }
+    }
+}
+
+
+// Disposes a clauses and removes it from watcher lists. NOTE! Low-level; does NOT change the 'clauses' and 'learnts' vector.
+//
+void Solver::remove(Clause* c, bool just_dealloc)
+{
+	
+#ifdef _MEMORY_ALLOCATION
+
+	uint decrease_memory = sizeof(Clause) + sizeof(uint)*(c->size() + (int)(c->learnt())); 
+	if(proof != NULL) decrease_memory++;
+	assert(memory_counter >= decrease_memory);
+	memory_counter -= decrease_memory;
+
+#endif
+
+    if (!just_dealloc){
+        removeWatch(watches[index(~(*c)[0])], c),
+        removeWatch(watches[index(~(*c)[1])], c);
+
+        if (c->learnt()) stats.learnts_literals -= c->size();
+        else             stats.clauses_literals -= c->size();
+
+        if (proof != NULL) proof->deleted(c->id());
+	}
+	
+    xfree(c);
+}
+
+
+// Can assume everything has been propagated! (esp. the first two literals are != l_False, unless
+// the clause is binary and satisfied, in which case the first literal is true)
+// Returns True if clause is satisfied (will be removed), False otherwise.
+//
+bool Solver::simplify(Clause* c) const
+{
+    assert(decisionLevel() == 0);
+    for (int i = 0; i < c->size(); i++){
+        if (value((*c)[i]) == l_True)
+            return true;
+    }
+    return false;
+}
+
+
+//=================================================================================================
+// Minor methods:
+
+
+// Creates a new SAT variable in the solver. If 'decision_var' is cleared, variable will not be
+// used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
+//
+Var Solver::newVar() {
+    int     index;
+    index = nVars();
+    watches     .push();          // (list for positive literal)
+    watches     .push();          // (list for negative literal)
+    reason      .push(NULL);
+    assigns     .push(toInt(l_Undef));
+    level       .push(-1);
+    trail_pos   .push(-1);
+    activity    .push(0);
+    order       .newVar();
+    analyze_seen.push(0);
+	polarity	.push(true); //RM: polarity controls the phase of the branching variable
+    if (proof != NULL) unit_id.push(ClauseId_NULL);
+    return index; }
+
+
+// Returns FALSE if immediate conflict.
+bool Solver::assume(Lit p) {
+    trail_lim.push(trail.size());
+    return enqueue(p); }
+
+
+// Revert to the state at given level.
+void Solver::cancelUntil(int level) {
+    if (decisionLevel() > level){
+        for (int c = trail.size()-1; c >= trail_lim[level]; c--){
+            Var     x  = var(trail[c]);
+			polarity[x] = sign(trail[c]); //RM: progress saving heuristic
+            assigns[x] = toInt(l_Undef);
+            reason [x] = NULL;
+            order.undo(x); }
+        trail.shrink(trail.size() - trail_lim[level]);
+        trail_lim.shrink(trail_lim.size() - level);
+        qhead = trail.size(); } }
+
+
+//=================================================================================================
+// Major methods:
+
+
+/*_________________________________________________________________________________________________
+|
+|  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
+|  
+|  Description:
+|    Analyze conflict and produce a reason clause ('out_learnt') and a backtracking level
+|    ('out_btlevel').
+|  
+|    Pre-conditions:
+|      * 'out_learnt' is assumed to be cleared.
+|      * Current decision level must be greater than root level.
+|  
+|    Post-conditions:
+|      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
+|      * If performing proof-logging, the last derived clause in the proof is the reason clause.
+|________________________________________________________________________________________________@*/
+
+class lastToFirst_lt {  // Helper class to 'analyze' -- order literals from last to first occurance in 'trail[]'.
+    const vec<int>& trail_pos;
+public:
+    lastToFirst_lt(const vec<int>& t) : trail_pos(t) {}
+    bool operator () (Lit p, Lit q) { return trail_pos[var(p)] > trail_pos[var(q)]; }
+};
+
+void Solver::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel, ClauseId &out_id)
+{
+    vec<char>&     seen  = analyze_seen;
+    int            pathC = 0;
+    Lit            p     = lit_Undef;
+    out_id = ClauseId_NULL;
+
+    // Generate conflict clause:
+    //
+    if (proof != NULL) proof->beginChain(confl->id());
+    out_learnt.push();          // (leave room for the asserting literal)
+    out_btlevel = 0;
+    int index = trail.size()-1;
+    for(;;){
+        assert(confl != NULL);  // (otherwise should be UIP)
+
+        Clause& c = *confl;
+        if (c.learnt())
+            claBumpActivity(&c);
+
+        for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
+            Lit q = c[j];
+            if (!seen[var(q)]){                      
+                if (level[var(q)] > 0){                  
+                    varBumpActivity(q);
+                    seen[var(q)] = 1;                    
+                    if (level[var(q)] == decisionLevel())
+                        pathC++;
+                    else{
+                        out_learnt.push(q);
+                        out_btlevel = max(out_btlevel, level[var(q)]);
+                    }
+                }else
+                  // CMW: Need phase of pivot.
+                  //if (proof != NULL) proof->resolve(unit_id[var(q)], var(q));
+                  if (proof != NULL) proof->resolve(unit_id[var(q)], q);
+            }
+        }
+
+        // Select next clause to look at:
+        while (!seen[var(trail[index--])]);
+        p     = trail[index+1];
+        confl = reason[var(p)];
+        seen[var(p)] = 0;
+        pathC--;
+        if (pathC == 0) break;
+
+        // CMW: Need phase of pivot.
+        //if (proof != NULL) proof->resolve(confl->id(), var(p));
+        if (proof != NULL) proof->resolve(confl->id(), ~p);
+    }
+    out_learnt[0] = ~p;
+
+    // Conflict clause minimization:
+    //
+#ifdef CC_MINIMIZATION
+    int     i, j;
+    if (expensive_ccmin){
+        // Simplify conflict clause (a lot):
+        //
+        uint    min_level = 0;
+        for (i = 1; i < out_learnt.size(); i++)
+            min_level |= 1 << (level[var(out_learnt[i])] & 31);         // (maintain an abstraction of levels involved in conflict)
+
+        analyze_toclear.clear();
+        for (i = j = 1; i < out_learnt.size(); i++)
+            if (reason[var(out_learnt[i])] == NULL || !analyze_removable(out_learnt[i], min_level))
+                out_learnt[j++] = out_learnt[i];
+    }else{
+        // Simplify conflict clause (a little):
+        //
+        analyze_toclear.clear();
+        for (i = j = 1; i < out_learnt.size(); i++){
+            Clause* r = reason[var(out_learnt[i])];
+            if (r == NULL)
+                out_learnt[j++] = out_learnt[i];
+            else{
+                Clause& c = *r;
+                for (int k = 1; k < c.size(); k++)
+                    if (!seen[var(c[k])] && level[var(c[k])] != 0){
+                        out_learnt[j++] = out_learnt[i];
+                        goto Keep;
+                    }
+                analyze_toclear.push(out_learnt[i]);
+              Keep:;
+            }
+        }
+    }
+#else
+    int i = 0, j = 0;
+#endif
+
+    // Finilize proof logging with conflict clause minimization steps:
+    //
+    if (proof != NULL){
+        sort(analyze_toclear, lastToFirst_lt(trail_pos));
+        for (int k = 0; k < analyze_toclear.size(); k++){
+            Var     v = var(analyze_toclear[k]); assert(level[v] > 0);
+            Clause& c = *reason[v];
+            // CMW: Need phase of pivot
+            // proof->resolve(c.id(), v);
+            proof->resolve(c.id(), analyze_toclear[k]);
+            for (int l = 1; l < c.size(); l++)
+                if (level[var(c[l])] == 0)
+                  // CMW: Need phase of pivot
+                  // proof->resolve(unit_id[var(c[k])], var(c[k]));
+                  proof->resolve(unit_id[var(c[l])], c[l]);
+        }
+        out_id = proof->endChain();
+    }
+    // Clean up:
+    //
+    for (int j = 0; j < out_learnt.size()     ; j++) seen[var(out_learnt     [j])] = 0;
+    for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
+
+    stats.max_literals += out_learnt.size();
+    out_learnt.shrink(i - j);
+    stats.tot_literals += out_learnt.size();
+}
+
+
+// Check if 'p' can be removed. 'min_level' is used to abort early if visiting literals at a level that cannot be removed.
+//
+bool Solver::analyze_removable(Lit p, uint min_level)
+{
+    assert(reason[var(p)] != NULL);
+    analyze_stack.clear(); analyze_stack.push(p);
+    int top = analyze_toclear.size();
+    while (analyze_stack.size() > 0){
+        assert(reason[var(analyze_stack.last())] != NULL);
+        Clause& c = *reason[var(analyze_stack.last())];
+        analyze_stack.pop();
+        for (int i = 1; i < c.size(); i++){
+            Lit p = c[i];
+            if (!analyze_seen[var(p)] && level[var(p)] != 0){
+                if (reason[var(p)] != NULL && ((1 << (level[var(p)] & 31)) & min_level) != 0){
+                    analyze_seen[var(p)] = 1;
+                    analyze_stack.push(p);
+                    analyze_toclear.push(p);
+                }else{
+                    for (int j = top; j < analyze_toclear.size(); j++)
+                        analyze_seen[var(analyze_toclear[j])] = 0;
+                    analyze_toclear.shrink(analyze_toclear.size() - top);
+                    return false;
+                }
+            }
+        }
+    }
+    analyze_toclear.push(p);
+
+    return true;
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  analyzeFinal : (confl : Clause*) (skip_first : bool)  ->  [void]
+|  
+|  Description:
+|    Specialized analysis procedure to express the final conflict in terms of assumptions.
+|    'root_level' is allowed to point beyond end of trace (useful if called after conflict while
+|    making assumptions). If 'skip_first' is TRUE, the first literal of 'confl' is  ignored (needed
+|    if conflict arose before search even started).
+|________________________________________________________________________________________________@*/
+void Solver::analyzeFinal(Clause* confl, bool skip_first)
+{
+    // -- NOTE! This code is relatively untested. Please report bugs!
+    conflict.clear();
+    if (root_level == 0){
+        if (proof != NULL) conflict_id = proof->last();
+        return; }
+
+    vec<char>&     seen  = analyze_seen;
+    if (proof != NULL) proof->beginChain(confl->id());
+    for (int i = skip_first ? 1 : 0; i < confl->size(); i++){
+        Var     x = var((*confl)[i]);
+        if (level[x] > 0)
+            seen[x] = 1;
+        else
+          // CMW: Need phase of pivot.
+          //if (proof != NULL) proof->resolve(unit_id[x], x);
+          if (proof != NULL) proof->resolve(unit_id[x], (*confl)[i]);
+    }
+
+    int     start = (root_level >= trail_lim.size()) ? trail.size()-1 : trail_lim[root_level];
+    for (int i = start; i >= trail_lim[0]; i--){
+        Var     x = var(trail[i]);
+        if (seen[x]){
+            Clause* r = reason[x];
+            if (r == NULL){
+                assert(level[x] > 0);
+                conflict.push(~trail[i]);
+            }else{
+                Clause& c = *r;
+                // CMW: Need phase of pivot.
+                //if (proof != NULL) proof->resolve(c.id(), x);
+                if (proof != NULL) proof->resolve(c.id(), ~trail[i]);
+                for (int j = 1; j < c.size(); j++)
+                    if (level[var(c[j])] > 0)
+                        seen[var(c[j])] = 1;
+                    else
+                      // CMW: Need phase of pivot.
+                      // if (proof != NULL) proof->resolve(unit_id[var(c[j])], var(c[j]));
+                      if (proof != NULL) proof->resolve(unit_id[var(c[j])], c[j]);
+            }
+            seen[x] = 0;
+        }
+    }
+    if (proof != NULL) conflict_id = proof->endChain();
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  enqueue : (p : Lit) (from : Clause*)  ->  [bool]
+|  
+|  Description:
+|    Puts a new fact on the propagation queue as well as immediately updating the variable's value.
+|    Should a conflict arise, FALSE is returned.
+|  
+|  Input:
+|    p    - The fact to enqueue
+|    from - [Optional] Fact propagated from this (currently) unit clause. Stored in 'reason[]'.
+|           Default value is NULL (no reason).
+|  
+|  Output:
+|    TRUE if fact was enqueued without conflict, FALSE otherwise.
+|________________________________________________________________________________________________@*/
+bool Solver::enqueue(Lit p, Clause* from)
+{
+    if (value(p) != l_Undef)
+        return value(p) != l_False;
+    else{
+        Var     x = var(p);
+        assigns  [x] = toInt(lbool(!sign(p)));
+        level    [x] = decisionLevel();
+        trail_pos[x] = trail.size();
+        reason   [x] = from;
+        trail.push(p);
+        return true;
+    }
+}
+
+
+
+/*_________________________________________________________________________________________________
+|
+|  propagate : [void]  ->  [Clause*]
+|  
+|  Description:
+|    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
+|    otherwise NULL. NOTE! This method has been optimized for speed rather than readability.
+|  
+|    Post-conditions:
+|      * The propagation queue is empty, even if there was a conflict.
+|________________________________________________________________________________________________@*/
+Clause* Solver::propagate()
+{    
+    Clause* confl = NULL;
+    while (qhead < trail.size()){
+        stats.propagations++;
+        simpDB_props--;
+
+        Lit            p  = trail[qhead++];     // 'p' is enqueued fact to propagate.
+        vec<Clause*>&  ws = watches[index(p)];
+        Clause**       i,** j,** end;
+
+        for (i = j = (Clause**)ws, end = i + ws.size();  i != end;){
+            Clause& c = **i; i++;
+            // Make sure the false literal is data[1]:
+            Lit false_lit = ~p;
+            if (c[0] == false_lit)
+                c[0] = c[1], c[1] = false_lit;
+
+            assert(c[1] == false_lit);
+
+            // If 0th watch is true, then clause is already satisfied.
+            Lit   first = c[0];
+            lbool val   = value(first);
+            if (val == l_True){
+                *j++ = &c;
+            }else{
+                // Look for new watch:
+                for (int k = 2; k < c.size(); k++)
+                    if (value(c[k]) != l_False){
+                        c[1] = c[k]; c[k] = false_lit;
+                        watches[index(~c[1])].push(&c);
+                        goto FoundWatch; }
+
+                // Did not find watch -- clause is unit under assignment:
+                if (decisionLevel() == 0 && proof != NULL){
+                    // Log the production of this unit clause:
+                    proof->beginChain(c.id());
+                    for (int k = 1; k < c.size(); k++)
+                    {
+                      // CMW: Need phase of pivot.
+                      // proof->resolve(unit_id[var(c[k])], var(c[k]));
+                      Lit l = c[k];
+                      int v = var(l);                      
+                      ClauseId uid = unit_id[v];
+                      proof->resolve(uid, l);
+                    }
+                    ClauseId id = proof->endChain();
+                    assert(unit_id[var(first)] == ClauseId_NULL || value(first) == l_False);    // (if variable already has 'id', it must be with the other polarity and we should have derived the empty clause here)
+                    if (value(first) != l_False)
+                        unit_id[var(first)] = id;
+                    else{
+                        // Empty clause derived:
+                        proof->beginChain(unit_id[var(first)]);
+                        // CMW: Need phase of pivot.
+                        //proof->resolve(id, var(first));
+                        proof->resolve(id, ~first);
+                        proof->endChain();
+                    }
+                }
+
+                *j++ = &c;
+                if (!enqueue(first, &c)){
+                    if (decisionLevel() == 0)
+                        ok = false;
+                    confl = &c;
+                    qhead = trail.size();
+                    // Copy the remaining watches:
+                    while (i < end)
+                        *j++ = *i++;
+                }
+              FoundWatch:;
+            }
+        }
+        ws.shrink((int) (i - j));
+    }
+
+    return confl;
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  reduceDB : ()  ->  [void]
+|  
+|  Description:
+|    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
+|    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
+|________________________________________________________________________________________________@*/
+struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };
+void Solver::reduceDB()
+{
+    int     i, j;
+    double  extra_lim = cla_inc / learnts.size();    // Remove any clause below this activity
+
+    sort(learnts, reduceDB_lt());
+    for (i = j = 0; i < learnts.size() / 2; i++){
+        if (learnts[i]->size() > 2 && !locked(learnts[i]))
+            remove(learnts[i]);
+        else
+            learnts[j++] = learnts[i];
+    }
+    for (; i < learnts.size(); i++){
+        if (learnts[i]->size() > 2 && !locked(learnts[i]) && learnts[i]->activity() < extra_lim)
+            remove(learnts[i]);
+        else
+            learnts[j++] = learnts[i];
+    }
+    learnts.shrink(i - j);
+
+    reduce_callback();
+}
+
+void Solver::splitDB(vec<vec<Lit> > &split_clauses)
+{
+	int	j;
+
+	if(clauses.size() % 2 == 0) j = clauses.size() / 2;
+	else j = (clauses.size()-1) /2;
+
+	int removed = 0;
+
+	while(removed < j)
+	{
+		int last = clauses.size()-1;
+
+		vec<Lit> read_clause;
+		for(int z = 0; z < clauses[last]->size(); z++)
+		{
+			   Clause& c = *clauses[last];
+			   Lit p = c[z];
+			   //if(sign(p)) std::cout << -var(p) << " ";
+			   //else std::cout << var(p) << " ";
+			   read_clause.push(p);
+		}
+		//std::cout << std::endl;
+			
+		split_clauses.push(read_clause);
+		//std::cout << "removing clause: "<< removed << " remaining: " << clauses.size() << " goal: " << j << std::endl;
+		remove(clauses[last]);
+
+		clauses.pop();
+
+		removed++;
+	}
+	
+}
+
+void Solver::getAndRemovePosition(std::vector<signed> &last_clause, int position, int type)
+{
+	//type : ORIGINAL 0; LEARNT 1; HALFLEARNT 2
+	cancelUntil(0);
+
+	last_clause.clear();
+
+	int last = position;
+	int size = 0;
+
+	switch(type)
+	{
+	case 0:
+		if (clauses.size() > 0)
+		{
+			size = clauses[last]->size();
+			Clause& c = *clauses[last];
+
+			for (int i = 0; i < size; i++)
+			{
+				Lit p = c[i];
+				if (sign(p)) last_clause.push_back(-var(p));
+				else last_clause.push_back(var(p));
+			}
+			remove(clauses[last]);
+
+			for(int i = last; i < clauses.size()-1; i++)
+				clauses[i] = clauses[i+1];
+
+			clauses.pop();
+
+		}
+		break;
+
+	case 1:
+		if (learnts.size() > 0)
+		{
+			last = position;
+			while (last >= 0)
+			{
+				if (locked(learnts[last]))
+					last--;
+				else break;
+			}
+
+			if (last >= 0)
+			{
+				size = learnts[last]->size();
+				Clause& c = *learnts[last];
+				assert(!locked(learnts[last]));
+				for (int i = 0; i < size; i++)
+				{
+					Lit p = c[i];
+					if (sign(p)) last_clause.push_back(-var(p));
+					else last_clause.push_back(var(p));
+				}
+				remove(learnts[last]);
+
+				for(int i = last; i < learnts.size()-1; i++)
+					learnts[i] = learnts[i+1];
+
+				learnts.pop();
+			}
+
+	case 2:
+		if (halflearnts.size() > 0)
+		{
+			size = halflearnts[last]->size();
+			Clause& c = *halflearnts[last];
+
+			for (int i = 0; i < size; i++)
+			{
+				Lit p = c[i];
+				if (sign(p)) last_clause.push_back(-var(p));
+				else last_clause.push_back(var(p));
+			}
+			remove(halflearnts[last]);
+
+			for(int i = last; i < halflearnts.size()-1; i++)
+				halflearnts[i] = halflearnts[i+1];
+
+			halflearnts.pop();
+		}
+		break;
+
+	default:
+		throw std::exception("type of clause not defined");	
+		}
+
+	}
+}
+
+void Solver::getAndRemoveLast(std::vector<signed> &last_clause, int type)
+{
+
+	//type : ORIGINAL 0; LEARNT 1; HALFLEARNT 2
+	cancelUntil(0);
+
+	last_clause.clear();
+
+	int last = 0;
+	int size = 0;
+	
+	switch (type)
+	{
+	case 0: //ORIGINAL
+		if (clauses.size() > 0)
+		{
+			last = clauses.size()-1;
+			size = clauses[last]->size();
+			Clause& c = *clauses[last];
+			for (int i = 0; i < size; i++)
+			{
+				Lit p = c[i];
+				if (sign(p)) last_clause.push_back(-var(p));
+				else last_clause.push_back(var(p));
+			}
+			remove(clauses[last]);
+			clauses.pop();
+		}
+		break;
+	case 1: //LEARNT
+		if (learnts.size() > 0)
+		{
+			last = learnts.size()-1;
+			while (last >= 0)
+			{
+				if (locked(learnts[last]))
+					last--;
+				else break;
+			}
+
+			if (last >= 0)
+			{
+				size = learnts[last]->size();
+				Clause& c = *learnts[last];
+				assert(!locked(learnts[last]));
+				for (int i = 0; i < size; i++)
+				{
+					Lit p = c[i];
+					if (sign(p)) last_clause.push_back(-var(p));
+					else last_clause.push_back(var(p));
+				}
+				remove(learnts[last]);
+
+				if(last != learnts.size()-1)
+				{
+					int i, j;
+					for (i = j = last; i < learnts.size(); i++)
+						learnts[j++] = learnts[i];
+
+					learnts.shrink(i - j);
+				} else learnts.pop();
+			}
+		}
+		break;
+	case 2: //HALFLEARNT
+		if (halflearnts.size() > 0)
+		{
+			last = halflearnts.size()-1;
+			size = halflearnts[last]->size();
+			Clause& c = *halflearnts[last];
+			for (int i = 0; i < size; i++)
+			{
+				Lit p = c[i];
+				if (sign(p)) last_clause.push_back(-var(p));
+				else last_clause.push_back(var(p));
+			}
+			remove(halflearnts[last]);
+			halflearnts.pop();
+		}
+		break;
+	default:
+		throw std::exception("type of clause not defined");
+	}
+
+}
+
+void Solver::removeLast(vec<vec<Lit> > &split_clauses)
+{
+	int last = clauses.size()-1;
+
+		vec<Lit> read_clause;
+		for(int z = 0; z < clauses[last]->size(); z++)
+		{
+			   Clause& c = *clauses[last];
+			   Lit p = c[z];
+			   //if(sign(p)) std::cout << -var(p) << " ";
+			   //else std::cout << var(p) << " ";
+			   read_clause.push(p);
+		}
+		//std::cout << std::endl;
+			
+		split_clauses.push(read_clause);
+		//std::cout << "removing clause: "<< removed << " remaining: " << clauses.size() << " goal: " << j << std::endl;
+		remove(clauses[last]);
+
+		clauses.pop();
+}
+
+void Solver::printDB(int rank)
+{
+	for(int i = 0; i < clauses.size(); i++)
+	{
+		Clause& c = *clauses[i];
+		std::cout << "[ "<< rank << " ] " ;
+		for(int z=0; z < clauses[i]->size(); z++)
+		{
+			Lit p = c[z];
+			if(sign(p)) std::cout << -var(p) << " ";
+			else std::cout << var(p) << " ";
+		}
+		std::cout << "0" << std::endl;
+
+	}
+	
+	cancelUntil(0);
+	for(int i=1; i < nVars(); i++)
+	{
+		if(value(i) != l_Undef){
+			if(value(i) == l_True)
+			std::cout << "c " << i << " 0" << std::endl;
+			else std::cout << "c " << -i << " 0" << std::endl;
+		}          
+	}
+
+}
+
+void Solver::getUnitClauses(std::set<int> &vars, int maxVar)
+{
+	cancelUntil(0);
+	for(int i=1; i <= maxVar; i++)
+	{
+		if(value(i) != l_Undef){
+			if(value(i) == l_True)
+			vars.insert(i);
+			else vars.insert(-i);
+		}          
+	}
+	
+}
+
+void Solver::getUsedVariables(std::set<int> &vars, int maxVar)
+{
+	for(int i=0; i < clauses.size(); i++)
+	{
+		 Clause& c = *clauses[i];
+		 for(int z=0;  z < clauses[i]->size(); z++)
+		 {
+			Lit p = c[z];
+			if(var(p) <= maxVar) vars.insert(var(p));
+		 }
+	}
+
+}
+
+void Solver::cleanLearnts()
+{
+
+	int i, j;
+
+	for (i = j = 0; i < learnts.size(); i++){
+        if (learnts[i]->size() > 2 && !locked(learnts[i]))
+            remove(learnts[i]);
+        else
+            learnts[j++] = learnts[i];
+    }
+    
+    learnts.shrink(i - j);
+
+	//for(int i = 0; i < learnts.size(); i++)
+	//	remove(learnts[i]);
+
+	//learnts.clear();
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  simplifyDB : [void]  ->  [bool]
+|  
+|  Description:
+|    Simplify the clause database according to the current top-level assigment. Currently, the only
+|    thing done here is the removal of satisfied clauses, but more things can be put here.
+|________________________________________________________________________________________________@*/
+void Solver::simplifyDB()
+{  
+    if (!ok) return;    // GUARD (public method)
+    assert(decisionLevel() == 0);    
+
+    if (propagate() != NULL){
+        ok = false;
+        return; }
+
+    if (nAssigns() == simpDB_assigns || simpDB_props > 0)   // (nothing has changed or preformed a simplification too recently)
+        return;
+
+    // Clear watcher lists:
+    // CMW: New clauses over the units may be added through interpolation!
+    for (int i = simpDB_assigns; i < nAssigns(); i++){
+    //for (int i = 0; i < nAssigns(); i++){
+        Lit p = trail[i];
+        watches[index( p)].clear(true);
+        watches[index(~p)].clear(true);
+    }
+
+    // Remove satisfied clauses:
+    for (int type = 0; type < 2; type++){
+        vec<Clause*>& cs = type ? learnts : clauses;
+        int           j  = 0;
+        for (int i = 0; i < cs.size(); i++){
+            if (!locked(cs[i]) && simplify(cs[i]))
+                remove(cs[i]);
+            else
+                cs[j++] = cs[i];
+        }
+        cs.shrink(cs.size()-j);
+    }
+
+    simpDB_assigns = nAssigns();
+    simpDB_props   = stats.clauses_literals + stats.learnts_literals;   // (shouldn't depend on 'stats' really, but it will do for now)
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  search : (nof_conflicts : int) (nof_learnts : int) (params : const SearchParams&)  ->  [lbool]
+|  
+|  Description:
+|    Search for a model the specified number of conflicts, keeping the number of learnt clauses
+|    below the provided limit. NOTE! Use negative value for 'nof_conflicts' or 'nof_learnts' to
+|    indicate infinity.
+|  
+|  Output:
+|    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
+|    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
+|    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
+|________________________________________________________________________________________________@*/
+lbool Solver::search(int nof_conflicts, int nof_learnts, const SearchParams& params)
+{
+	
+    if (!ok) return l_False;    // GUARD (public method)
+    assert(root_level == decisionLevel());
+
+    stats.starts++;
+    int     conflictC = 0;
+    var_decay = 1 / params.var_decay;
+    cla_decay = 1 / params.clause_decay;
+    model.clear();
+
+    for (;;){      
+
+		if (resources_limit)
+        {
+			double solving_time = 0;
+			if(resources_time > 0) solving_time = (clock() - start)/(double)CLOCKS_PER_SEC;
+
+			if((resources_conflicts > 0 && stats.conflicts_limit > resources_conflicts) ||
+				(resources_clauses > 0 && learnts.size() > resources_clauses) ||
+				(resources_time > 0 && solving_time > resources_time))
+			{
+				resources_exhausted = true;
+				cancelUntil(0);
+				return l_False;
+			}		
+		}
+
+        Clause* confl = propagate();
+        if (confl != NULL){
+            // CONFLICT
+
+			stats.conflicts++; conflictC++; stats.conflicts_limit++;
+            //vec<Lit>    learnt_clause;
+            //int         backtrack_level;
+            if (decisionLevel() == root_level){
+                // Contradiction found:
+                analyzeFinal(confl);
+                return l_False; }
+
+            //analyze(confl, learnt_clause, backtrack_level);
+            //cancelUntil(max(backtrack_level, root_level));
+            //newClause(learnt_clause, true, (proof != NULL) ? proof->last() : ClauseId_NULL);
+            //if (learnt_clause.size() == 1) level[var(learnt_clause[0])] = 0;    // (this is ugly (but needed for 'analyzeFinal()') -- in future versions, we will backtrack past the 'root_level' and redo the assumptions)
+            
+            // CMW: overridable conflict analysis
+            if (!resolve_conflict(confl))
+              return l_False;
+
+            varDecayActivity();
+            claDecayActivity();
+
+        }else{
+            // NO CONFLICT
+
+            if (nof_conflicts >= 0 && conflictC >= nof_conflicts){
+                // Reached bound on number of conflicts:
+                progress_estimate = progressEstimate();
+                cancelUntil(root_level);
+                return l_Undef; }
+            
+
+            if (decisionLevel() == 0)
+                // Simplify the set of problem clauses:
+                simplifyDB(), assert(ok);
+
+
+            if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
+                // Reduce the set of learnt clauses:
+                reduceDB();
+
+
+            if (partial_models)
+            {
+              if (checkSatisfaction()){
+                  // Model found:
+                  model.growTo(nVars());
+                  for (int i = 0; i < nVars(); i++) model[i] = value(i);
+                  cancelUntil(root_level);
+                  return l_True;
+              }
+
+              // New variable decision:
+              stats.decisions++;
+              Var next = order.select(params.random_var_freq);
+			  //RM 16/05/2012: phase saving heuristic when choosing a new variable decision
+			  (!phase_saving || polarity[next]) ? check(next!=var_Undef && assume(~Lit(next))) : check(next!=var_Undef && assume(Lit(next)));
+	        } else {
+              // New variable decision:
+              stats.decisions++;
+              Var next = order.select(params.random_var_freq);
+
+              if (next == var_Undef){
+                  // Model found:
+                  model.growTo(nVars());
+                  for (int i = 0; i < nVars(); i++) model[i] = value(i);
+                  cancelUntil(root_level);
+                  return l_True;
+              }
+			  //RM: phase saving heuristic when choosing a new variable decision
+			  (!phase_saving || polarity[next]) ? check(assume(~Lit(next))) : check(assume(Lit(next)));
+			}
+        }
+    }
+}
+
+
+// Return search-space coverage. Not extremely reliable.
+//
+double Solver::progressEstimate()
+{
+    double  progress = 0;
+    double  F = 1.0 / nVars();
+    for (int i = 0; i < nVars(); i++)
+        if (value(i) != l_Undef)
+            progress += pow(F, level[i]);
+    return progress / nVars();
+}
+
+
+// Divide all variable activities by 1e100.
+//
+void Solver::varRescaleActivity()
+{
+    for (int i = 0; i < nVars(); i++)
+        activity[i] *= 1e-100;
+    var_inc *= 1e-100;
+}
+
+
+// Divide all constraint activities by 1e100.
+//
+void Solver::claRescaleActivity()
+{
+    for (int i = 0; i < learnts.size(); i++)
+        learnts[i]->activity() *= (float)1e-20;
+    cla_inc *= 1e-20;
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  solve : (assumps : const vec<Lit>&)  ->  [bool]
+|  
+|  Description:
+|    Top-level solve. If using assumptions (non-empty 'assumps' vector), you must call
+|    'simplifyDB()' first to see that no top-level conflict is present (which would put the solver
+|    in an undefined state).
+|  
+|  Input:
+|    A list of assumptions (unit clauses coded as literals). Pre-condition: The assumptions must
+|    not contain both 'x' and '~x' for any variable 'x'.
+|________________________________________________________________________________________________@*/
+bool Solver::solve(const vec<Lit>& assumps)
+{
+
+	//std::cout << "Assumptions inside the solver: ";
+	//for(int i=0; i < assumps.size(); i++){
+	//	Lit l = assumps[i];
+	//	int v = var(l);
+	//	if(sign(l)) std::cout << -v << " ";
+	//	else std::cout << v << " ";
+	//}
+	//std::cout << std::endl;
+
+	start = clock();
+	stats.conflicts_limit = 0;
+
+	cancelUntil(0);
+
+    simplifyDB();
+    if (!ok) return false;
+
+    SearchParams    params(default_params);
+    double  nof_conflicts = 100;
+    double  nof_learnts   = nClauses() / 3;
+    lbool   status        = l_Undef;
+
+	double inner = 100;
+	double outer = 100;
+
+    // Perform assumptions:
+    root_level = assumps.size();
+    for (int i = 0; i < assumps.size(); i++){
+        Lit p = assumps[i];
+        assert(var(p) < nVars());
+        if (!assume(p)){
+            if (reason[var(p)] != NULL){
+                analyzeFinal(reason[var(p)], true);
+                conflict.push(~p);
+            }else{
+                assert(proof == NULL || unit_id[var(p)] != ClauseId_NULL);   // (this is the pre-condition above)
+                conflict.clear();
+                conflict.push(~p);
+                if (proof != NULL) conflict_id = unit_id[var(p)];
+            }
+            cancelUntil(0);
+            return false; }
+        Clause* confl = propagate();
+        if (confl != NULL){
+            analyzeFinal(confl), assert(conflict.size() > 0);
+            cancelUntil(0);
+            return false; }
+    }
+    assert(root_level == decisionLevel());
+
+    // Search:
+    if (verbosity >= 1){
+        reportf("==================================[MINISAT]===================================\n");
+        reportf("| Conflicts |     ORIGINAL     |              LEARNT              | Progress |\n");
+        reportf("|           | Clauses Literals |   Limit Clauses Literals  Lit/Cl |          |\n");
+        reportf("==============================================================================\n");
+    }
+
+
+	// for (int i=0; i<clauses.size(); i++)
+ // {
+ //   const Clause &c = *clauses[i];
+	//	std::cout << "( ";
+ //    for (int j=0; j<c.size(); j++){
+	//	 const Lit &l = c[j];
+	//		int v = var(l);
+	//		if(sign(l)) std::cout << -v << " ";
+	//		else std::cout << v << " ";
+	//}
+	// std::cout << ")" << std::endl;
+	// }
+	
+	while (status == l_Undef){
+        if (verbosity >= 1){
+            reportf("| %9d | %7d %8d | %7d %7d %8d %7.1f | %6.3f %% |\n", (int)stats.conflicts, nClauses(), (int)stats.clauses_literals, (int)nof_learnts, nLearnts(), (int)stats.learnts_literals, (double)stats.learnts_literals/nLearnts(), progress_estimate*100);
+            fflush(stdout);
+        }
+        status = search((int)nof_conflicts, (int)nof_learnts, params);
+
+		//default restart strategy
+		if(!fast_restart)
+		{		
+        nof_conflicts *= 1.5;
+        nof_learnts   *= 1.1;
+		} else {
+
+		//armin restart strategy
+		if (inner>=outer) {
+			outer *= 1.1;
+			inner = 100; 
+            
+        } else {
+            inner *= 1.1;
+        }
+		nof_conflicts = ceil(inner);
+		}
+	}
+    if (verbosity >= 1)
+        reportf("==============================================================================\n");
+
+    cancelUntil(0);
+
+    if (model_lifting && status == l_True)
+      liftModel(assumps);
+
+    return status == l_True;
+}
+
+bool Solver::resolve_conflict(Clause *confl)
+{
+  vec<Lit>    learnt_clause;
+  int         backtrack_level;
+
+  ClauseId c_id = ClauseId_NULL;
+  analyze(confl, learnt_clause, backtrack_level, c_id);
+  assert(!proof || c_id!=ClauseId_NULL);
+  //std::cout << "BTL: " << backtrack_level << std::endl;
+  cancelUntil(max(backtrack_level, root_level));
+  newClause(learnt_clause, true, c_id);
+  //std::cout << "ASSERTING: " << var(learnt_clause[0]) << std::endl;
+  if (learnt_clause.size() == 1) level[var(learnt_clause[0])] = 0;  // (this is ugly (but needed for 'analyzeFinal()') -- in future versions, we will backtrack past the 'root_level' and redo the assumptions)
+  return true;
+}
+
+void Solver::liftModel(const vec<Lit>& assumps)
+{
+  //std::cout << "Lifting model " << std::endl;
+  unsigned lifted = 0;
+  vec<bool> requiredVars(nVars(), false);
+  bool progress = true;
+
+  for (int i = 0; i < nVars(); i++)
+      if (level[i] == 0)
+        requiredVars[var(trail[i])] = true;
+
+  while (progress)
+  {    
+    //std::cout << "Lifting ... " << std::endl;
+    progress = false;
+
+    for (int i=0; i<clauses.size(); i++)
+    {
+      const Clause &c = *clauses[i];
+      unsigned trueCnt = 0;
+      Lit lastTrue;
+
+      for (int j=0; j<c.size(); j++)
+      {
+        const Lit &l = c[j];
+        unsigned v = var(l);
+        bool sgn = sign(l);
+            
+        if ((!sgn && model[v]==l_True) ||
+            (sgn && model[v]==l_False))
+        {
+          if (requiredVars[v]) 
+            goto nextClause;
+          else
+          {
+            trueCnt++;
+            lastTrue = l;
+          }
+        }
+
+        requiredVars[ var(lastTrue) ] = true;
+        progress = true;
+      }
+
+      nextClause: ;
+    }
+  }
+    
+  for (int i=0; i<assumps.size(); i++)
+    requiredVars[var(assumps[i])] = true;
+
+  for (int i=0; i<model.size(); i++)
+    if (!requiredVars[i] && level[i] > root_level)
+    {
+      // std::cout << "Not required: " << i << std::endl;
+      model[i] = l_Undef;
+    }
+}
+
+bool Solver::checkSatisfaction()
+{
+  bool sat;
+
+  for (int i=0; i<clauses.size(); i++)
+  {
+    const Clause &c = *clauses[i];
+    sat=false;
+    for (int j=0; j<c.size(); j++)
+      if (value(c[j])==l_True) { sat=true; break; }
+    if (!sat) return false;
+  }
+
+  return true;
+}
+
+/*
+void Solver::findWatch(const vec<Clause*>& ws, const Clause* elem) const
+{  
+  if (ws.size()==0) 
+  {
+    std::cout << "CLAUSE NOT FOUND" << std::endl;
+    for (int i=0; i<elem->size(); i++)
+    {
+      lbool v = value((*elem)[i]);
+      std::cout << " " << toDimacs((*elem)[i]) << "(" << ((v==l_True)?1:(v==l_Undef)?2:0) << ")";
+    }
+    std::cout << std::endl;
+    throw std::exception("Watchlist empty!");
+  }
+
+  int j = 0;
+  for (; ws[j] != elem  ; j++) 
+  { 
+    if (j==ws.size()) 
+    {
+      std::cout << "CLAUSE NOT FOUND" << std::endl;
+        for (int i=0; i<elem->size(); i++)
+        {
+          lbool v = value((*elem)[i]);
+          std::cout << " " << toDimacs((*elem)[i]) << "(" << ((v==l_True)?1:(v==l_Undef)?2:0) << ")";
+        }
+        std::cout << std::endl;
+      throw std::exception("Clause not found"); 
+    }
+  }
+}
+
+void Solver::checkWatches(const vec<Clause *> &cl) const
+{
+  for (int i=0; i<cl.size(); i++)
+  {
+    const Clause &c = *cl[i];
+    if (level[var(c[0])]!=0) findWatch(watches[index(~c[0])], &c);
+    if (level[var(c[1])]!=0) findWatch(watches[index(~c[1])], &c);
+  }
+}
+*/
\ No newline at end of file
diff -rupN ./Solver.h ..\Minisat/Solver.h
--- ./Solver.h	2014-02-26 14:57:06.889382900 +0000
+++ ..\Minisat/Solver.h	2012-07-27 16:51:03.566897800 +0100
@@ -1,212 +1,344 @@
-/****************************************************************************************[Solver.h]
-MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-associated documentation files (the "Software"), to deal in the Software without restriction,
-including without limitation the rights to use, copy, modify, merge, publish, distribute,
-sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or
-substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
-OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
-
-#ifndef Solver_h
-#define Solver_h
-
-#include "SolverTypes.h"
-#include "VarOrder.h"
-#include "Proof.h"
-
-// Redfine if you want output to go somewhere else:
-#define reportf(format, args...) ( printf(format , ## args), fflush(stdout) )
-
-
-//=================================================================================================
-// Solver -- the main class:
-
-
-struct SolverStats {
-    int64   starts, decisions, propagations, conflicts;
-    int64   clauses_literals, learnts_literals, max_literals, tot_literals;
-    SolverStats() : starts(0), decisions(0), propagations(0), conflicts(0)
-      , clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0) { }
-};
-
-
-struct SearchParams {
-    double  var_decay, clause_decay, random_var_freq;    // (reasonable values are: 0.95, 0.999, 0.02)    
-    SearchParams(double v = 1, double c = 1, double r = 0) : var_decay(v), clause_decay(c), random_var_freq(r) { }
-};
-
-
-class Solver {
-protected:
-    // Solver state:
-    //
-    bool                ok;               // If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!
-    vec<Clause*>        clauses;          // List of problem clauses.
-    vec<Clause*>        learnts;          // List of learnt clauses.
-    vec<ClauseId>       unit_id;          // 'unit_id[var]' is the clause ID for the unit literal 'var' or '~var' (if set at toplevel).
-    double              cla_inc;          // Amount to bump next clause with.
-    double              cla_decay;        // INVERSE decay factor for clause activity: stores 1/decay.
-
-    vec<double>         activity;         // A heuristic measurement of the activity of a variable.
-    double              var_inc;          // Amount to bump next variable with.
-    double              var_decay;        // INVERSE decay factor for variable activity: stores 1/decay. Use negative value for static variable order.
-    VarOrder            order;            // Keeps track of the decision variable order.
-
-    vec<vec<Clause*> >  watches;          // 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).
-    vec<char>           assigns;          // The current assignments (lbool:s stored as char:s).
-    vec<Lit>            trail;            // Assignment stack; stores all assigments made in the order they were made.
-    vec<int>            trail_lim;        // Separator indices for different decision levels in 'trail[]'.
-    vec<Clause*>        reason;           // 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.
-    vec<int>            level;            // 'level[var]' is the decision level at which assignment was made.
-    vec<int>            trail_pos;        // 'trail_pos[var]' is the variable's position in 'trail[]'. This supersedes 'level[]' in some sense, and 'level[]' will probably be removed in future releases.
-    int                 root_level;       // Level of first proper decision.
-    int                 qhead;            // Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).
-    int                 simpDB_assigns;   // Number of top-level assignments since last execution of 'simplifyDB()'.
-    int64               simpDB_props;     // Remaining number of propagations that must be made before next execution of 'simplifyDB()'.
-
-    // Temporaries (to reduce allocation overhead). Each variable is prefixed by the method in which is used:
-    //
-    vec<char>           analyze_seen;
-    vec<Lit>            analyze_stack;
-    vec<Lit>            analyze_toclear;
-    Clause*             propagate_tmpbin;
-    Clause*             analyze_tmpbin;
-    vec<Lit>            addUnit_tmp;
-    vec<Lit>            addBinary_tmp;
-    vec<Lit>            addTernary_tmp;
-
-    // Main internal methods:
-    //
-    bool        assume           (Lit p);
-    void        cancelUntil      (int level);
-    void        record           (const vec<Lit>& clause);
-
-    void        analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel); // (bt = backtrack)
-    bool        analyze_removable(Lit p, uint min_level);                                 // (helper method for 'analyze()')
-    void        analyzeFinal     (Clause* confl, bool skip_first = false);
-    bool        enqueue          (Lit fact, Clause* from = NULL);
-    Clause*     propagate        ();
-    void        reduceDB         ();
-    Lit         pickBranchLit    (const SearchParams& params);
-    lbool       search           (int nof_conflicts, int nof_learnts, const SearchParams& params);
-    double      progressEstimate ();
-
-    // Activity:
-    //
-    void     varBumpActivity(Lit p) {
-        if (var_decay < 0) return;     // (negative decay means static variable order -- don't bump)
-        if ( (activity[var(p)] += var_inc) > 1e100 ) varRescaleActivity();
-        order.update(var(p)); }
-    void     varDecayActivity  () { if (var_decay >= 0) var_inc *= var_decay; }
-    void     varRescaleActivity();
-    void     claDecayActivity  () { cla_inc *= cla_decay; }
-    void     claRescaleActivity();
-
-    // Operations on clauses:
-    //
-    void     newClause(const vec<Lit>& ps, bool learnt = false, ClauseId id = ClauseId_NULL);
-    void     claBumpActivity (Clause* c) { if ( (c->activity() += cla_inc) > 1e20 ) claRescaleActivity(); }
-    void     remove          (Clause* c, bool just_dealloc = false);
-    bool     locked          (const Clause* c) const { return reason[var((*c)[0])] == c; }
-    bool     simplify        (Clause* c) const;
-
-    int      decisionLevel() const { return trail_lim.size(); }
-
-public:
-    Solver() : ok               (true)
-             , cla_inc          (1)
-             , cla_decay        (1)
-             , var_inc          (1)
-             , var_decay        (1)
-             , order            (assigns, activity)
-             , qhead            (0)
-             , simpDB_assigns   (0)
-             , simpDB_props     (0)
-             , default_params   (SearchParams(0.95, 0.999, 0.02))
-             , expensive_ccmin  (true)
-             , proof            (NULL)
-             , verbosity        (0)
-             , progress_estimate(0)
-             , conflict_id      (ClauseId_NULL)
-             {
-                vec<Lit> dummy(2,lit_Undef);
-                propagate_tmpbin = Clause_new(false, dummy);
-                analyze_tmpbin   = Clause_new(false, dummy);
-                addUnit_tmp   .growTo(1);
-                addBinary_tmp .growTo(2);
-                addTernary_tmp.growTo(3);
-             }
-
-   ~Solver() {
-       for (int i = 0; i < learnts.size(); i++) remove(learnts[i], true);
-       for (int i = 0; i < clauses.size(); i++) if (clauses[i] != NULL) remove(clauses[i], true);
-       remove(propagate_tmpbin, true);
-       remove(analyze_tmpbin, true);
-    }
-
-    // Helpers: (semi-internal)
-    //
-    lbool   value(Var x) const { return toLbool(assigns[x]); }
-    lbool   value(Lit p) const { return sign(p) ? ~toLbool(assigns[var(p)]) : toLbool(assigns[var(p)]); }
-
-    int     nAssigns() { return trail.size(); }
-    int     nClauses() { return clauses.size(); }
-    int     nLearnts() { return learnts.size(); }
-
-    // Statistics: (read-only member variable)
-    //
-    SolverStats     stats;
-
-    // Mode of operation:
-    //
-    SearchParams    default_params;     // Restart frequency etc.
-    bool            expensive_ccmin;    // Controls conflict clause minimization. TRUE by default.
-    Proof*          proof;              // Set this directly after constructing 'Solver' to enable proof logging. Initialized to NULL.
-    int             verbosity;          // Verbosity level. 0=silent, 1=some progress report, 2=everything
-
-    // Problem specification:
-    //
-    Var     newVar    ();
-    int     nVars     ()                    { return assigns.size(); }
-    void    addUnit   (Lit p)               { addUnit_tmp   [0] = p; addClause(addUnit_tmp); }
-    void    addBinary (Lit p, Lit q)        { addBinary_tmp [0] = p; addBinary_tmp [1] = q; addClause(addBinary_tmp); }
-    void    addTernary(Lit p, Lit q, Lit r) { addTernary_tmp[0] = p; addTernary_tmp[1] = q; addTernary_tmp[2] = r; addClause(addTernary_tmp); }
-    void    addClause (const vec<Lit>& ps)  { newClause(ps); }  // (used to be a difference between internal and external method...)
-
-    // Solving:
-    //
-    bool    okay() { return ok; }       // FALSE means solver is in an conflicting state (must never be used again!)
-    void    simplifyDB();
-    bool    solve(const vec<Lit>& assumps);
-    bool    solve() { vec<Lit> tmp; return solve(tmp); }
-
-    double      progress_estimate;  // Set by 'search()'.
-    vec<lbool>  model;              // If problem is satisfiable, this vector contains the model (if any).
-    vec<Lit>    conflict;           // If problem is unsatisfiable under assumptions, this vector represent the conflict clause expressed in the assumptions.
-    ClauseId    conflict_id;        // (In proof logging mode only.) ID for the clause 'conflict' (for proof traverseral). NOTE! The empty clause is always the last clause derived, but for conflicts under assumption, this is not necessarly true.
-};
-
-
-//=================================================================================================
-// Debug:
-
-
-#define L_LIT    "%s%d"
-#define L_lit(p) sign(p)?"-":"", var(p)+1
-
-// Just like 'assert()' but expression will be evaluated in the release version as well.
-inline void check(bool expr) { assert(expr); }
-
-
-//=================================================================================================
-#endif
+/****************************************************************************************[Solver.h]
+MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Solver_h
+#define Solver_h
+
+#include <stdarg.h>
+
+#include <time.h>
+
+#include "SolverTypes.h"
+#include "VarOrder.h"
+#include "Proof.h"
+
+#include <set>
+#include <vector>
+
+// Redfine if you want output to go somewhere else:
+// #define reportf(format, args...) ( printf(format , ## args), fflush(stdout) )
+
+inline void reportf(const char *format, ...)
+{
+  va_list args;
+  va_start(args, format);
+  vprintf(format, args);
+  va_end(args);
+  fflush(stdout);
+}
+
+
+//=================================================================================================
+// Solver -- the main class:
+
+
+struct SolverStats {
+    int64   starts, decisions, propagations, conflicts, conflicts_limit;
+    int64   clauses_literals, learnts_literals, max_literals, tot_literals;
+    SolverStats() : starts(0), decisions(0), propagations(0), conflicts(0)
+      , clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0), conflicts_limit(0) { }
+};
+
+
+struct SearchParams {
+    double  var_decay, clause_decay, random_var_freq;    // (reasonable values are: 0.95, 0.999, 0.02)    
+    SearchParams(double v = 1, double c = 1, double r = 0) : var_decay(v), clause_decay(c), random_var_freq(r) { }
+};
+
+
+class Solver {
+protected:
+    // Solver state:
+    //
+    bool                ok;               // If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!
+    vec<Clause*>        clauses;          // List of problem clauses.
+    vec<Clause*>        learnts;          // List of learnt clauses.
+    vec<ClauseId>       unit_id;          // 'unit_id[var]' is the clause ID for the unit literal 'var' or '~var' (if set at toplevel).
+    double              cla_inc;          // Amount to bump next clause with.
+    double              cla_decay;        // INVERSE decay factor for clause activity: stores 1/decay.
+
+    vec<double>         activity;         // A heuristic measurement of the activity of a variable.
+    double              var_inc;          // Amount to bump next variable with.
+    double              var_decay;        // INVERSE decay factor for variable activity: stores 1/decay. Use negative value for static variable order.
+    VarOrder            order;            // Keeps track of the decision variable order.
+
+    vec<vec<Clause*> >  watches;          // 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).
+    vec<char>           assigns;          // The current assignments (lbool:s stored as char:s).
+    vec<Lit>            trail;            // Assignment stack; stores all assigments made in the order they were made.
+    vec<int>            trail_lim;        // Separator indices for different decision levels in 'trail[]'.
+    vec<Clause*>        reason;           // 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.
+    vec<int>            level;            // 'level[var]' is the decision level at which assignment was made.
+    vec<int>            trail_pos;        // 'trail_pos[var]' is the variable's position in 'trail[]'. This supersedes 'level[]' in some sense, and 'level[]' will probably be removed in future releases.
+    int                 root_level;       // Level of first proper decision.
+    int                 qhead;            // Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).
+    int                 simpDB_assigns;   // Number of top-level assignments since last execution of 'simplifyDB()'.
+    int64               simpDB_props;     // Remaining number of propagations that must be made before next execution of 'simplifyDB()'.
+
+	//RM 16/05/2012: progress saving heuristic
+	vec<char>			polarity;		  // controls the phase of the branching variables
+	bool				phase_saving;	  // enable/disable phase_saving heuristic
+	bool				fast_restart;
+	vec<Clause*>		halflearnts;
+
+    // Temporaries (to reduce allocation overhead). Each variable is prefixed by the method in which is used:
+    //
+    vec<char>           analyze_seen;
+    vec<Lit>            analyze_stack;
+    vec<Lit>            analyze_toclear;
+    Clause*             propagate_tmpbin;
+    Clause*             analyze_tmpbin;
+    vec<Lit>            addUnit_tmp;
+    vec<Lit>            addBinary_tmp;
+    vec<Lit>            addTernary_tmp;
+
+    // Main internal methods:
+    //
+    bool        assume           (Lit p);
+    void        cancelUntil      (int level);
+    void        record           (const vec<Lit>& clause);
+
+    // CMW: overridable conflict analysis
+    virtual bool resolve_conflict(Clause *confl);
+    void        analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel, ClauseId &out_id); // (bt = backtrack)
+    bool        analyze_removable(Lit p, uint min_level);                                 // (helper method for 'analyze()')
+    void        analyzeFinal     (Clause* confl, bool skip_first = false);
+    bool        enqueue          (Lit fact, Clause* from = NULL);
+    Clause*     propagate        ();
+    void        reduceDB         ();
+    Lit         pickBranchLit    (const SearchParams& params);
+    lbool       search           (int nof_conflicts, int nof_learnts, const SearchParams& params);
+    double      progressEstimate ();
+
+    // Activity:
+    //
+    void     varBumpActivity(Lit p) {
+        if (var_decay < 0) return;     // (negative decay means static variable order -- don't bump)
+        if ( (activity[var(p)] += var_inc) > 1e100 ) varRescaleActivity();
+        order.update(var(p)); }
+    void     varDecayActivity  () { if (var_decay >= 0) var_inc *= var_decay; }
+    void     varRescaleActivity();
+    void     claDecayActivity  () { cla_inc *= cla_decay; }
+    void     claRescaleActivity();
+
+    // Operations on clauses:
+    //
+    void     newClause(const vec<Lit>& ps, bool learnt = false, ClauseId id = ClauseId_NULL, bool enqueue_asserting=true, bool halflearnt=false);
+    void     claBumpActivity (Clause* c) { if ( (c->activity() += (float)cla_inc) > 1e20 ) claRescaleActivity(); }
+    void     remove          (Clause* c, bool just_dealloc = false);
+    bool     locked          (const Clause* c) const { return reason[var((*c)[0])] == c; }
+    bool     simplify        (Clause* c) const;
+
+    int   decisionLevel() const { return trail_lim.size(); }
+
+    bool checkSatisfaction();
+    void liftModel(const vec<Lit>& assumps);
+
+public:
+    Solver() : ok               (true)
+             , cla_inc          (1)
+             , cla_decay        (1)
+             , var_inc          (1)
+             , var_decay        (1)
+             , order            (assigns, activity)
+             , qhead            (0)
+             , simpDB_assigns   (0)
+             , simpDB_props     (0)
+             , default_params   (SearchParams(0.95, 0.999, 0.02))
+             , expensive_ccmin  (true)
+             , proof            (NULL)
+             , verbosity        (0)
+             , progress_estimate(0)
+             , conflict_id      (ClauseId_NULL)			 
+             // CMW: Options
+             , partial_models   (false)
+             , model_lifting    (false)
+			 //RM: Options
+			 , memory_limit			(1073741824)
+			 , memory_counter		(0)
+			 , resources_exhausted	(false)
+			 , resources_limit		(false)
+			 , resources_conflicts	(0)
+			 , resources_clauses	(0)
+             , phase_saving		(false)
+			 , fast_restart		(false)
+			 //Minisat
+             {
+                vec<Lit> dummy(2,lit_Undef);
+#ifdef _MEMORY_ALLOCATION
+				propagate_tmpbin = Clause_new(false, dummy, memory_counter, memory_limit);
+				analyze_tmpbin   = Clause_new(false, dummy, memory_counter, memory_limit);
+#else 
+				propagate_tmpbin = Clause_new(false, dummy);
+				analyze_tmpbin   = Clause_new(false, dummy);
+#endif
+                addUnit_tmp   .growTo(1);
+                addBinary_tmp .growTo(2);
+                addTernary_tmp.growTo(3);
+             }
+
+   ~Solver() {
+       for (int i = 0; i < learnts.size(); i++) remove(learnts[i], true);
+       for (int i = 0; i < clauses.size(); i++) if (clauses[i] != NULL) remove(clauses[i], true);
+       remove(propagate_tmpbin, true);
+       remove(analyze_tmpbin, true);
+    }
+
+    // Helpers: (semi-internal)
+    //
+    lbool   value(Var x) const { return toLbool(assigns[x]); }
+    lbool   value(Lit p) const { return sign(p) ? ~toLbool(assigns[var(p)]) : toLbool(assigns[var(p)]); }
+
+    int  nAssigns() const { return trail.size(); }
+    int  nClauses() const { return clauses.size(); }
+    int  nLearnts() const { return learnts.size(); }
+	int	 nHalfLearnts() const { return halflearnts.size(); }
+
+    // Statistics: (read-only member variable)
+    //
+    SolverStats     stats;
+
+    // Mode of operation:
+    //
+    SearchParams    default_params;     // Restart frequency etc.
+    bool            expensive_ccmin;    // Controls conflict clause minimization. TRUE by default.
+    Proof*          proof;              // Set this directly after constructing 'Solver' to enable proof logging. Initialized to NULL.
+    int             verbosity;          // Verbosity level. 0=silent, 1=some progress report, 2=everything
+
+    // Problem specification:
+    //
+    Var     newVar    ();
+    int     nVars     () const              { return (unsigned) assigns.size(); }
+    void    addUnit   (Lit p)               { addUnit_tmp   [0] = p; addClause(addUnit_tmp); }
+    void    addBinary (Lit p, Lit q)        { addBinary_tmp [0] = p; addBinary_tmp [1] = q; addClause(addBinary_tmp); }
+    void    addTernary(Lit p, Lit q, Lit r) { addTernary_tmp[0] = p; addTernary_tmp[1] = q; addTernary_tmp[2] = r; addClause(addTernary_tmp); }
+    void    addClause (const vec<Lit>& ps)  { newClause(ps); }  // (used to be a difference between internal and external method...)
+	void	addLearntClause(const vec<Lit>& ps) { newClause(ps, true, ClauseId_NULL, false); }
+	void	addHalfLearntClause(const vec<Lit>& ps) { newClause(ps, true, ClauseId_NULL, false, true); }
+
+    // Solving:
+    //
+    bool    okay() { return ok; }       // FALSE means solver is in an conflicting state (must never be used again!)
+    void    simplifyDB();
+    bool    solve(const vec<Lit>& assumps);
+    bool    solve() { vec<Lit> tmp; return solve(tmp); }
+
+    double      progress_estimate;  // Set by 'search()'.
+    vec<lbool>  model;              // If problem is satisfiable, this vector contains the model (if any).
+    vec<Lit>    conflict;           // If problem is unsatisfiable under assumptions, this vector represent the conflict clause expressed in the assumptions.
+    ClauseId    conflict_id;        // (In proof logging mode only.) ID for the clause 'conflict' (for proof traverseral). NOTE! The empty clause is always the last clause derived, but for conflicts under assumption, this is not necessarly true.
+    
+	// RM: Options
+	bool resources_limit;
+	bool resources_exhausted;
+	int resources_conflicts;
+	int resources_clauses;
+	int resources_time;
+	clock_t start;
+	uint memory_limit;
+	uint memory_counter;
+
+	void setMemoryLimit(int mlimit) { memory_limit = mlimit; }
+	uint getUsedMemory(void) { return memory_counter; }
+
+	void getAndRemovePosition(std::vector<signed> &last_clause, int position, int type);
+	void getAndRemoveLast(std::vector<signed> &last_clause, int type);
+	void removeLast(vec<vec<Lit> > &split_clauses);
+	void splitDB(vec<vec<Lit> > &split_clauses);
+	void getUsedVariables(std::set<int> &var, int maxVar);
+	void getUnitClauses(std::set<int> &vars, int maxVar);
+	void cleanLearnts();
+	void printDB(int rank);
+
+	void updateFormulaVariables(std::vector<bool> &occurs)
+	{
+		for (int i = 0; i < clauses.size(); i++)
+		{ 
+			Clause &c = *clauses[i];
+			for (int j = 0; j < c.size(); j++)
+			{
+				if (!occurs[var(c[j])]) occurs[var(c[j])] = true; 
+			}
+		}
+
+		for (int i = 0; i < learnts.size(); i++)
+		{
+			Clause &c = *learnts[i];
+			for (int j = 0; j < c.size(); j++)
+			{
+				if (!occurs[var(c[j])]) occurs[var(c[j])] = true; 
+			}
+		}
+
+		for (int i = 0; i < halflearnts.size(); i++)
+		{
+			Clause &c = *halflearnts[i];
+			for (int j = 0; j < c.size(); j++)
+			{
+				if (!occurs[var(c[j])]) occurs[var(c[j])] = true; 
+			}
+		}
+
+	}
+
+	void setLimitResources(int conflicts, int clauses, int time){
+
+		if(conflicts != 0 || clauses !=0 || time != 0)
+		{
+			resources_limit = true;
+			resources_conflicts = conflicts;
+			resources_clauses = clauses;
+			resources_time = time;
+		}
+		else resources_limit = false;
+
+	}
+
+	bool getResources()
+	{
+		bool r = resources_exhausted;
+		resources_exhausted = false;
+		return r;
+	}
+
+    // CMW: Options
+    bool partial_models, model_lifting;
+
+    // CMW: Debug
+    /*
+    void findWatch(const vec<Clause*>& ws, const Clause* elem) const;
+    void checkWatches(const vec<Clause *> &cl) const;    
+    */
+
+    virtual void reduce_callback(void) {}
+};
+
+
+//=================================================================================================
+// Debug:
+
+
+#define L_LIT    "%s%d"
+#define L_lit(p) sign(p)?"-":"", var(p)+1
+
+// Just like 'assert()' but expression will be evaluated in the release version as well.
+inline void check(bool expr) { assert(expr); }
+
+
+//=================================================================================================
+#endif
diff -rupN ./SolverTypes.h ..\Minisat/SolverTypes.h
--- ./SolverTypes.h	2014-02-26 14:57:06.905007500 +0000
+++ ..\Minisat/SolverTypes.h	2012-07-23 12:25:22.684113200 +0100
@@ -1,139 +1,164 @@
-/***********************************************************************************[SolverTypes.h]
-MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-associated documentation files (the "Software"), to deal in the Software without restriction,
-including without limitation the rights to use, copy, modify, merge, publish, distribute,
-sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or
-substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
-OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
-
-
-#ifndef SolverTypes_h
-#define SolverTypes_h
-
-#ifndef Global_h
-#include "Global.h"
-#endif
-
-
-//=================================================================================================
-// Variables, literals, clause IDs:
-
-
-// NOTE! Variables are just integers. No abstraction here. They should be chosen from 0..N,
-// so that they can be used as array indices.
-
-typedef int Var;
-#define var_Undef (-1)
-
-
-class Lit {
-    int     x;
-public:
-    Lit() : x(2*var_Undef) {}   // (lit_Undef)
-    explicit Lit(Var var, bool sgn = false) : x((var+var) + (int)sgn) {}
-    friend Lit operator ~ (Lit p);
-
-    friend bool sign  (Lit p);
-    friend int  var   (Lit p);
-    friend int  index (Lit p);
-    friend Lit  toLit (int i);
-    friend Lit  unsign(Lit p);
-    friend Lit  id    (Lit p, bool sgn);
-
-    friend bool operator == (Lit p, Lit q);
-    friend bool operator <  (Lit p, Lit q);
-
-    uint hash() const { return (uint)x; }
-};
-inline Lit operator ~ (Lit p) { Lit q; q.x = p.x ^ 1; return q; }
-inline bool sign  (Lit p) { return p.x & 1; }
-inline int  var   (Lit p) { return p.x >> 1; }
-inline int  index (Lit p) { return p.x; }                // A "toInt" method that guarantees small, positive integers suitable for array indexing.
-inline Lit  toLit (int i) { Lit p; p.x = i; return p; }  // Inverse of 'index()'.
-inline Lit  unsign(Lit p) { Lit q; q.x = p.x & ~1; return q; }
-inline Lit  id    (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }
-inline bool operator == (Lit p, Lit q) { return index(p) == index(q); }
-inline bool operator <  (Lit p, Lit q) { return index(p)  < index(q); }  // '<' guarantees that p, ~p are adjacent in the ordering.
-
-const Lit lit_Undef(var_Undef, false);  // }- Useful special constants.
-const Lit lit_Error(var_Undef, true );  // }
-
-inline int toDimacs(Lit p) { return sign(p) ? -var(p) - 1 : var(p) + 1; }
-
-
-//=================================================================================================
-// Clause -- a simple class for representing a clause:
-
-
-typedef int ClauseId;     // (might have to use uint64 one day...)
-const   int ClauseId_NULL = INT_MIN;
-
-//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-
-class Clause {
-    uint    size_learnt;
-    Lit     data[1];
-public:
-    // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
-    Clause(bool learnt, const vec<Lit>& ps, ClauseId id_ = ClauseId_NULL) {
-        size_learnt = (ps.size() << 1) | (int)learnt;
-        for (int i = 0; i < ps.size(); i++) data[i] = ps[i];
-        if (learnt) activity() = 0;
-        if (id_ != ClauseId_NULL) id() = id_; }
-
-    // -- use this function instead:
-    friend Clause* Clause_new(bool, const vec<Lit>&, ClauseId);
-
-    int       size        ()      const { return size_learnt >> 1; }
-    bool      learnt      ()      const { return size_learnt & 1; }
-    Lit       operator [] (int i) const { return data[i]; }
-    Lit&      operator [] (int i)       { return data[i]; }
-    float&    activity    ()      const { return *((float*)&data[size()]); }
-    ClauseId& id          ()      const { return *((ClauseId*)&data[size() + (int)learnt()]); }
-};
-
-inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, ClauseId id = ClauseId_NULL) {
-    assert(sizeof(Lit)      == sizeof(uint));
-    assert(sizeof(float)    == sizeof(uint));
-    assert(sizeof(ClauseId) == sizeof(uint));
-    void*   mem = xmalloc<char>(sizeof(Clause) + sizeof(uint)*(ps.size() + (int)learnt + (int)(id != ClauseId_NULL)));
-    return new (mem) Clause(learnt, ps, id); }
-
-
-//=================================================================================================
-// GClause -- Generalize clause:
-
-
-// Either a pointer to a clause or a literal.
-class GClause {
-    void*   data;
-    GClause(void* d) : data(d) {}
-public:
-    friend GClause GClause_new(Lit p);
-    friend GClause GClause_new(Clause* c);
-
-    bool        isLit    () const { return ((uintp)data & 1) == 1; }
-    Lit         lit      () const { return toLit(((intp)data) >> 1); }
-    Clause*     clause   () const { return (Clause*)data; }
-    bool        operator == (GClause c) const { return data == c.data; }
-    bool        operator != (GClause c) const { return data != c.data; }
-};
-inline GClause GClause_new(Lit p)     { return GClause((void*)(((intp)index(p) << 1) + 1)); }
-inline GClause GClause_new(Clause* c) { assert(((uintp)c & 1) == 0); return GClause((void*)c); }
-
-#define GClause_NULL GClause_new((Clause*)NULL)
-
-
-//=================================================================================================
-#endif
+/***********************************************************************************[SolverTypes.h]
+MiniSat -- Copyright (c) 2003-2005, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+
+#ifndef SolverTypes_h
+#define SolverTypes_h
+
+#ifndef Global_h
+#include "Global.h"
+#endif
+
+#define _MEMORY_ALLOCATION 1
+
+//=================================================================================================
+// Variables, literals, clause IDs:
+
+
+// NOTE! Variables are just integers. No abstraction here. They should be chosen from 0..N,
+// so that they can be used as array indices.
+
+typedef int Var;
+#define var_Undef (-1)
+
+
+class Lit {
+    int     x;
+public:
+    Lit() : x(2*var_Undef) {}   // (lit_Undef)
+    explicit Lit(Var var, bool sgn = false) : x((var+var) + (int)sgn) {}
+    friend Lit operator ~ (Lit p);
+
+    friend bool sign  (Lit p);
+    friend int  var   (Lit p);
+    friend int  index (Lit p);
+    friend Lit  toLit (int i);
+    friend Lit  unsign(Lit p);
+    friend Lit  id    (Lit p, bool sgn);
+
+    friend bool operator == (Lit p, Lit q);
+    friend bool operator <  (Lit p, Lit q);
+
+    uint hash() const { return (uint)x; }
+};
+inline Lit operator ~ (Lit p) { Lit q; q.x = p.x ^ 1; return q; }
+inline bool sign  (Lit p) { return p.x & 1; }
+inline int  var   (Lit p) { return p.x >> 1; }
+inline int  index (Lit p) { return p.x; }                // A "toInt" method that guarantees small, positive integers suitable for array indexing.
+inline Lit  toLit (int i) { Lit p; p.x = i; return p; }  // Inverse of 'index()'.
+inline Lit  unsign(Lit p) { Lit q; q.x = p.x & ~1; return q; }
+inline Lit  id    (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }
+inline bool operator == (Lit p, Lit q) { return index(p) == index(q); }
+inline bool operator <  (Lit p, Lit q) { return index(p)  < index(q); }  // '<' guarantees that p, ~p are adjacent in the ordering.
+
+const Lit lit_Undef(var_Undef, false);  // }- Useful special constants.
+const Lit lit_Error(var_Undef, true );  // }
+
+inline int toDimacs(Lit p) { return sign(p) ? -var(p) - 1 : var(p) + 1; }
+
+
+//=================================================================================================
+// Clause -- a simple class for representing a clause:
+
+
+typedef int ClauseId;     // (might have to use uint64 one day...)
+const   int ClauseId_NULL = INT_MIN;
+
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+class Clause {
+    uint    size_learnt;
+    Lit     data[1];
+public:
+    // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
+    Clause(bool learnt, const vec<Lit>& ps, ClauseId id_ = ClauseId_NULL) {
+        size_learnt = (unsigned) (ps.size() << 1) | (int)learnt;
+        for (int i = 0; i < ps.size(); i++) data[i] = ps[i];
+        if (learnt) activity() = 0;
+        if (id_ != ClauseId_NULL) id() = id_; }
+
+    // -- use this function instead:
+    
+	//RM: new definition of Clause_new
+#ifdef _MEMORY_ALLOCATION
+	friend Clause* Clause_new(bool, const vec<Lit>&, uint&, uint, ClauseId);
+#else
+	friend Clause* Clause_new(bool, const vec<Lit>&, ClauseId);
+#endif
+
+    int       size        ()      const { return (signed) size_learnt >> 1; }
+    bool      learnt      ()      const { return size_learnt & 1; }
+    Lit       operator [] (int i) const { return data[i]; }
+    Lit&      operator [] (int i)       { return data[i]; }
+    float&    activity    ()      const { return *((float*)&data[size()]); }
+    ClauseId& id          ()      const { return *((ClauseId*)&data[size() + (int)learnt()]); }
+};
+
+#ifdef _MEMORY_ALLOCATION
+
+inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, uint &memory_counter, uint memory_limit, ClauseId id = ClauseId_NULL) {
+	assert(sizeof(Lit)      == sizeof(uint));
+	assert(sizeof(float)    == sizeof(uint));
+	assert(sizeof(ClauseId) == sizeof(uint));
+
+	uint increase_memory = sizeof(Clause) + sizeof(uint)*(ps.size() + (int)learnt + (int)(id != ClauseId_NULL));
+	memory_counter += increase_memory;
+	if(memory_counter > memory_limit) throw std::bad_alloc();
+	
+	
+	void*   mem = xmalloc<char>(sizeof(Clause) + sizeof(uint)*(ps.size() + (int)learnt + (int)(id != ClauseId_NULL)));
+	return new (mem) Clause(learnt, ps, id); }
+
+#else
+
+inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, ClauseId id = ClauseId_NULL) {
+	assert(sizeof(Lit)      == sizeof(uint));
+	assert(sizeof(float)    == sizeof(uint));
+	assert(sizeof(ClauseId) == sizeof(uint));
+	void*   mem = xmalloc<char>(sizeof(Clause) + sizeof(uint)*(ps.size() + (int)learnt + (int)(id != ClauseId_NULL)));
+	return new (mem) Clause(learnt, ps, id); }
+
+#endif
+
+//=================================================================================================
+// GClause -- Generalize clause:
+
+
+// Either a pointer to a clause or a literal.
+class GClause {
+    void*   data;
+    GClause(void* d) : data(d) {}
+public:
+    friend GClause GClause_new(Lit p);
+    friend GClause GClause_new(Clause* c);
+
+    bool        isLit    () const { return ((unsigned)data & 1) == 1; }
+    Lit         lit      () const { return toLit(((signed)data) >> 1); }
+    Clause*     clause   () const { return (Clause*)data; }
+    bool        operator == (GClause c) const { return data == c.data; }
+    bool        operator != (GClause c) const { return data != c.data; }
+};
+inline GClause GClause_new(Lit p)     { return GClause((void*)(((unsigned)index(p) << 1) + 1)); }
+inline GClause GClause_new(Clause* c) { assert(((unsigned)c & 1) == 0); return GClause((void*)c); }
+
+#define GClause_NULL GClause_new((Clause*)NULL)
+
+
+//=================================================================================================
+#endif
diff -rupN ./VarOrder.h ..\Minisat/VarOrder.h
--- ./VarOrder.h	2014-02-26 14:57:06.951882300 +0000
+++ ..\Minisat/VarOrder.h	2011-04-26 16:06:07.540066500 +0100
@@ -23,14 +23,18 @@ OF OR IN CONNECTION WITH THE SOFTWARE OR
 #include "SolverTypes.h"
 #include "Heap.h"
 
+#define STOCK_ORDER
+//#define VARNUMBER_ORDER
 
 //=================================================================================================
 
+#if defined(STOCK_ORDER)
 
 struct VarOrder_lt {
     const vec<double>&  activity;
     bool operator () (Var x, Var y) { return activity[x] > activity[y]; }
     VarOrder_lt(const vec<double>&  act) : activity(act) { }
+    VarOrder_lt &operator=(const VarOrder_lt &) { assert(false); }
 };
 
 class VarOrder {
@@ -48,6 +52,8 @@ public:
     inline void update(Var x);                  // Called when variable increased in activity.
     inline void undo(Var x);                    // Called when variable is unassigned and may be selected again.
     inline Var  select(double random_freq =.0); // Selects a new, unassigned variable (or 'var_Undef' if none exists).
+
+    VarOrder &operator=(const VarOrder &) { assert(false); }
 };
 
 
@@ -91,6 +97,65 @@ Var VarOrder::select(double random_var_f
     return var_Undef;
 }
 
+#elif defined(VARNUMBER_ORDER)
+
+struct VarOrder_lt {    
+    bool operator () (Var x, Var y) { return x < y; }
+    VarOrder_lt(const vec<double>&  act) { }
+    VarOrder_lt &operator=(const VarOrder_lt &) { assert(false); }
+};
+
+class VarOrder {
+    const vec<char>&    assigns;     // var->val. Pointer to external assignment table.
+    Heap<VarOrder_lt>   heap; 
+
+public:
+    VarOrder(const vec<char>& ass, const vec<double>& act) :
+        assigns(ass), heap(VarOrder_lt(act))
+        { }
+
+    inline void newVar(void);
+    inline void update(Var x);                  // Called when variable increased in activity.
+    inline void undo(Var x);                    // Called when variable is unassigned and may be selected again.
+    inline Var  select(double random_freq =.0); // Selects a new, unassigned variable (or 'var_Undef' if none exists).
+
+    VarOrder &operator=(const VarOrder &) { assert(false); }
+};
+
+
+void VarOrder::newVar(void)
+{
+    heap.setBounds(assigns.size());
+    heap.insert(assigns.size()-1);
+}
+
+
+void VarOrder::update(Var x)
+{
+}
+
+
+void VarOrder::undo(Var x)
+{
+    if (!heap.inHeap(x))
+        heap.insert(x);
+}
+
+
+Var VarOrder::select(double random_var_freq)
+{
+    // Variable number based decision:
+    while (!heap.empty()){
+        Var next = heap.getmin();
+        if (toLbool(assigns[next]) == l_Undef)
+            return next;
+    }
+
+    return var_Undef;
+}
+#else
+#error No variable ordering selected.
+#endif
 
 //=================================================================================================
 #endif
